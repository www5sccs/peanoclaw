#ifndef _PEANOCLAW_RECORDS_STATE_H
#define _PEANOCLAW_RECORDS_STATE_H

#include "peano/utils/Globals.h"
#include "tarch/compiler/CompilerSpecificSettings.h"
#include "peano/utils/PeanoOptimisations.h"
#ifdef Parallel
	#include "tarch/parallel/Node.h"
#endif
#ifdef Parallel
	#include <mpi.h>
#endif
#include "tarch/logging/Log.h"
#include "tarch/la/Vector.h"
#include <bitset>
#include <complex>
#include <string>
#include <iostream>
#include "peano/utils/Globals.h"

namespace peanoclaw {
   namespace records {
      class State;
      class StatePacked;
   }
}

#if defined(Parallel)
   /**
    * @author This class is generated by DaStGen
    * 		   DataStructureGenerator (DaStGen)
    * 		   2007-2009 Wolfgang Eckhardt
    * 		   2012      Tobias Weinzierl
    *
    * 		   build date: 12-04-2013 09:18
    *
    * @date   18/07/2013 13:56
    */
   class peanoclaw::records::State { 
      
      public:
         
         typedef peanoclaw::records::StatePacked Packed;
         
         struct PersistentRecords {
            int _additionalLevelsForPredefinedRefinement;
            bool _isInitializing;
            bool _initialRefinmentTriggered;
            int _unknownsPerSubcell;
            int _auxiliarFieldsPerSubcell;
            #ifdef UseManualAlignment
            tarch::la::Vector<DIMENSIONS,double> _initialMinimalMeshWidth __attribute__((aligned(VectorisationAlignment)));
            #else
            tarch::la::Vector<DIMENSIONS,double> _initialMinimalMeshWidth;
            #endif
            #ifdef UseManualAlignment
            tarch::la::Vector<DIMENSIONS,int> _defaultSubdivisionFactor __attribute__((aligned(VectorisationAlignment)));
            #else
            tarch::la::Vector<DIMENSIONS,int> _defaultSubdivisionFactor;
            #endif
            int _defaultGhostWidthLayer;
            double _initialTimestepSize;
            bool _useDimensionalSplittingOptimization;
            double _globalTimestepEndTime;
            bool _allPatchesEvolvedToGlobalTimestep;
            #ifdef UseManualAlignment
            tarch::la::Vector<DIMENSIONS,double> _domainOffset __attribute__((aligned(VectorisationAlignment)));
            #else
            tarch::la::Vector<DIMENSIONS,double> _domainOffset;
            #endif
            #ifdef UseManualAlignment
            tarch::la::Vector<DIMENSIONS,double> _domainSize __attribute__((aligned(VectorisationAlignment)));
            #else
            tarch::la::Vector<DIMENSIONS,double> _domainSize;
            #endif
            int _plotNumber;
            int _subPlotNumber;
            double _startMaximumGlobalTimeInterval;
            double _endMaximumGlobalTimeInterval;
            double _startMinimumGlobalTimeInterval;
            double _endMinimumGlobalTimeInterval;
            double _minimalTimestep;
            double _totalNumberOfCellUpdates;
            #ifdef UseManualAlignment
            tarch::la::Vector<DIMENSIONS,double> _minMeshWidth __attribute__((aligned(VectorisationAlignment)));
            #else
            tarch::la::Vector<DIMENSIONS,double> _minMeshWidth;
            #endif
            #ifdef UseManualAlignment
            tarch::la::Vector<DIMENSIONS,double> _maxMeshWidth __attribute__((aligned(VectorisationAlignment)));
            #else
            tarch::la::Vector<DIMENSIONS,double> _maxMeshWidth;
            #endif
            double _numberOfInnerVertices;
            double _numberOfBoundaryVertices;
            double _numberOfOuterVertices;
            double _numberOfInnerCells;
            double _numberOfOuterCells;
            double _numberOfInnerLeafVertices;
            double _numberOfBoundaryLeafVertices;
            double _numberOfOuterLeafVertices;
            double _numberOfInnerLeafCells;
            double _numberOfOuterLeafCells;
            int _maxLevel;
            bool _hasRefined;
            bool _hasTriggeredRefinementForNextIteration;
            bool _hasErased;
            bool _hasTriggeredEraseForNextIteration;
            bool _hasChangedVertexOrCellState;
            bool _isTraversalInverted;
            bool _reduceStateAndCell;
            bool _couldNotEraseDueToDecompositionFlag;
            bool _subWorkerIsInvolvedInJoinOrFork;
            /**
             * Generated
             */
            PersistentRecords();
            
            /**
             * Generated
             */
            PersistentRecords(const int& additionalLevelsForPredefinedRefinement, const bool& isInitializing, const bool& initialRefinmentTriggered, const int& unknownsPerSubcell, const int& auxiliarFieldsPerSubcell, const tarch::la::Vector<DIMENSIONS,double>& initialMinimalMeshWidth, const tarch::la::Vector<DIMENSIONS,int>& defaultSubdivisionFactor, const int& defaultGhostWidthLayer, const double& initialTimestepSize, const bool& useDimensionalSplittingOptimization, const double& globalTimestepEndTime, const bool& allPatchesEvolvedToGlobalTimestep, const tarch::la::Vector<DIMENSIONS,double>& domainOffset, const tarch::la::Vector<DIMENSIONS,double>& domainSize, const int& plotNumber, const int& subPlotNumber, const double& startMaximumGlobalTimeInterval, const double& endMaximumGlobalTimeInterval, const double& startMinimumGlobalTimeInterval, const double& endMinimumGlobalTimeInterval, const double& minimalTimestep, const double& totalNumberOfCellUpdates, const tarch::la::Vector<DIMENSIONS,double>& minMeshWidth, const tarch::la::Vector<DIMENSIONS,double>& maxMeshWidth, const double& numberOfInnerVertices, const double& numberOfBoundaryVertices, const double& numberOfOuterVertices, const double& numberOfInnerCells, const double& numberOfOuterCells, const double& numberOfInnerLeafVertices, const double& numberOfBoundaryLeafVertices, const double& numberOfOuterLeafVertices, const double& numberOfInnerLeafCells, const double& numberOfOuterLeafCells, const int& maxLevel, const bool& hasRefined, const bool& hasTriggeredRefinementForNextIteration, const bool& hasErased, const bool& hasTriggeredEraseForNextIteration, const bool& hasChangedVertexOrCellState, const bool& isTraversalInverted, const bool& reduceStateAndCell, const bool& couldNotEraseDueToDecompositionFlag, const bool& subWorkerIsInvolvedInJoinOrFork);
            
            
            inline int getAdditionalLevelsForPredefinedRefinement() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _additionalLevelsForPredefinedRefinement;
            }
            
            
            
            inline void setAdditionalLevelsForPredefinedRefinement(const int& additionalLevelsForPredefinedRefinement) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _additionalLevelsForPredefinedRefinement = additionalLevelsForPredefinedRefinement;
            }
            
            
            
            inline bool getIsInitializing() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _isInitializing;
            }
            
            
            
            inline void setIsInitializing(const bool& isInitializing) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _isInitializing = isInitializing;
            }
            
            
            
            inline bool getInitialRefinmentTriggered() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _initialRefinmentTriggered;
            }
            
            
            
            inline void setInitialRefinmentTriggered(const bool& initialRefinmentTriggered) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _initialRefinmentTriggered = initialRefinmentTriggered;
            }
            
            
            
            inline int getUnknownsPerSubcell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _unknownsPerSubcell;
            }
            
            
            
            inline void setUnknownsPerSubcell(const int& unknownsPerSubcell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _unknownsPerSubcell = unknownsPerSubcell;
            }
            
            
            
            inline int getAuxiliarFieldsPerSubcell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _auxiliarFieldsPerSubcell;
            }
            
            
            
            inline void setAuxiliarFieldsPerSubcell(const int& auxiliarFieldsPerSubcell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _auxiliarFieldsPerSubcell = auxiliarFieldsPerSubcell;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline tarch::la::Vector<DIMENSIONS,double> getInitialMinimalMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _initialMinimalMeshWidth;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline void setInitialMinimalMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& initialMinimalMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _initialMinimalMeshWidth = (initialMinimalMeshWidth);
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline tarch::la::Vector<DIMENSIONS,int> getDefaultSubdivisionFactor() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _defaultSubdivisionFactor;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline void setDefaultSubdivisionFactor(const tarch::la::Vector<DIMENSIONS,int>& defaultSubdivisionFactor) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _defaultSubdivisionFactor = (defaultSubdivisionFactor);
            }
            
            
            
            inline int getDefaultGhostWidthLayer() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _defaultGhostWidthLayer;
            }
            
            
            
            inline void setDefaultGhostWidthLayer(const int& defaultGhostWidthLayer) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _defaultGhostWidthLayer = defaultGhostWidthLayer;
            }
            
            
            
            inline double getInitialTimestepSize() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _initialTimestepSize;
            }
            
            
            
            inline void setInitialTimestepSize(const double& initialTimestepSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _initialTimestepSize = initialTimestepSize;
            }
            
            
            
            inline bool getUseDimensionalSplittingOptimization() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _useDimensionalSplittingOptimization;
            }
            
            
            
            inline void setUseDimensionalSplittingOptimization(const bool& useDimensionalSplittingOptimization) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _useDimensionalSplittingOptimization = useDimensionalSplittingOptimization;
            }
            
            
            
            inline double getGlobalTimestepEndTime() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _globalTimestepEndTime;
            }
            
            
            
            inline void setGlobalTimestepEndTime(const double& globalTimestepEndTime) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _globalTimestepEndTime = globalTimestepEndTime;
            }
            
            
            
            inline bool getAllPatchesEvolvedToGlobalTimestep() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _allPatchesEvolvedToGlobalTimestep;
            }
            
            
            
            inline void setAllPatchesEvolvedToGlobalTimestep(const bool& allPatchesEvolvedToGlobalTimestep) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _allPatchesEvolvedToGlobalTimestep = allPatchesEvolvedToGlobalTimestep;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline tarch::la::Vector<DIMENSIONS,double> getDomainOffset() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _domainOffset;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline void setDomainOffset(const tarch::la::Vector<DIMENSIONS,double>& domainOffset) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _domainOffset = (domainOffset);
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline tarch::la::Vector<DIMENSIONS,double> getDomainSize() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _domainSize;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline void setDomainSize(const tarch::la::Vector<DIMENSIONS,double>& domainSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _domainSize = (domainSize);
            }
            
            
            
            inline int getPlotNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _plotNumber;
            }
            
            
            
            inline void setPlotNumber(const int& plotNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _plotNumber = plotNumber;
            }
            
            
            
            inline int getSubPlotNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _subPlotNumber;
            }
            
            
            
            inline void setSubPlotNumber(const int& subPlotNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _subPlotNumber = subPlotNumber;
            }
            
            
            
            inline double getStartMaximumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _startMaximumGlobalTimeInterval;
            }
            
            
            
            inline void setStartMaximumGlobalTimeInterval(const double& startMaximumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _startMaximumGlobalTimeInterval = startMaximumGlobalTimeInterval;
            }
            
            
            
            inline double getEndMaximumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _endMaximumGlobalTimeInterval;
            }
            
            
            
            inline void setEndMaximumGlobalTimeInterval(const double& endMaximumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _endMaximumGlobalTimeInterval = endMaximumGlobalTimeInterval;
            }
            
            
            
            inline double getStartMinimumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _startMinimumGlobalTimeInterval;
            }
            
            
            
            inline void setStartMinimumGlobalTimeInterval(const double& startMinimumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _startMinimumGlobalTimeInterval = startMinimumGlobalTimeInterval;
            }
            
            
            
            inline double getEndMinimumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _endMinimumGlobalTimeInterval;
            }
            
            
            
            inline void setEndMinimumGlobalTimeInterval(const double& endMinimumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _endMinimumGlobalTimeInterval = endMinimumGlobalTimeInterval;
            }
            
            
            
            inline double getMinimalTimestep() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _minimalTimestep;
            }
            
            
            
            inline void setMinimalTimestep(const double& minimalTimestep) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _minimalTimestep = minimalTimestep;
            }
            
            
            
            inline double getTotalNumberOfCellUpdates() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _totalNumberOfCellUpdates;
            }
            
            
            
            inline void setTotalNumberOfCellUpdates(const double& totalNumberOfCellUpdates) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _totalNumberOfCellUpdates = totalNumberOfCellUpdates;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline tarch::la::Vector<DIMENSIONS,double> getMinMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _minMeshWidth;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline void setMinMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& minMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _minMeshWidth = (minMeshWidth);
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline tarch::la::Vector<DIMENSIONS,double> getMaxMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _maxMeshWidth;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline void setMaxMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& maxMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _maxMeshWidth = (maxMeshWidth);
            }
            
            
            
            inline double getNumberOfInnerVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _numberOfInnerVertices;
            }
            
            
            
            inline void setNumberOfInnerVertices(const double& numberOfInnerVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _numberOfInnerVertices = numberOfInnerVertices;
            }
            
            
            
            inline double getNumberOfBoundaryVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _numberOfBoundaryVertices;
            }
            
            
            
            inline void setNumberOfBoundaryVertices(const double& numberOfBoundaryVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _numberOfBoundaryVertices = numberOfBoundaryVertices;
            }
            
            
            
            inline double getNumberOfOuterVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _numberOfOuterVertices;
            }
            
            
            
            inline void setNumberOfOuterVertices(const double& numberOfOuterVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _numberOfOuterVertices = numberOfOuterVertices;
            }
            
            
            
            inline double getNumberOfInnerCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _numberOfInnerCells;
            }
            
            
            
            inline void setNumberOfInnerCells(const double& numberOfInnerCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _numberOfInnerCells = numberOfInnerCells;
            }
            
            
            
            inline double getNumberOfOuterCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _numberOfOuterCells;
            }
            
            
            
            inline void setNumberOfOuterCells(const double& numberOfOuterCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _numberOfOuterCells = numberOfOuterCells;
            }
            
            
            
            inline double getNumberOfInnerLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _numberOfInnerLeafVertices;
            }
            
            
            
            inline void setNumberOfInnerLeafVertices(const double& numberOfInnerLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _numberOfInnerLeafVertices = numberOfInnerLeafVertices;
            }
            
            
            
            inline double getNumberOfBoundaryLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _numberOfBoundaryLeafVertices;
            }
            
            
            
            inline void setNumberOfBoundaryLeafVertices(const double& numberOfBoundaryLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _numberOfBoundaryLeafVertices = numberOfBoundaryLeafVertices;
            }
            
            
            
            inline double getNumberOfOuterLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _numberOfOuterLeafVertices;
            }
            
            
            
            inline void setNumberOfOuterLeafVertices(const double& numberOfOuterLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _numberOfOuterLeafVertices = numberOfOuterLeafVertices;
            }
            
            
            
            inline double getNumberOfInnerLeafCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _numberOfInnerLeafCells;
            }
            
            
            
            inline void setNumberOfInnerLeafCells(const double& numberOfInnerLeafCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _numberOfInnerLeafCells = numberOfInnerLeafCells;
            }
            
            
            
            inline double getNumberOfOuterLeafCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _numberOfOuterLeafCells;
            }
            
            
            
            inline void setNumberOfOuterLeafCells(const double& numberOfOuterLeafCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _numberOfOuterLeafCells = numberOfOuterLeafCells;
            }
            
            
            
            inline int getMaxLevel() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _maxLevel;
            }
            
            
            
            inline void setMaxLevel(const int& maxLevel) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _maxLevel = maxLevel;
            }
            
            
            
            inline bool getHasRefined() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _hasRefined;
            }
            
            
            
            inline void setHasRefined(const bool& hasRefined) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _hasRefined = hasRefined;
            }
            
            
            
            inline bool getHasTriggeredRefinementForNextIteration() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _hasTriggeredRefinementForNextIteration;
            }
            
            
            
            inline void setHasTriggeredRefinementForNextIteration(const bool& hasTriggeredRefinementForNextIteration) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _hasTriggeredRefinementForNextIteration = hasTriggeredRefinementForNextIteration;
            }
            
            
            
            inline bool getHasErased() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _hasErased;
            }
            
            
            
            inline void setHasErased(const bool& hasErased) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _hasErased = hasErased;
            }
            
            
            
            inline bool getHasTriggeredEraseForNextIteration() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _hasTriggeredEraseForNextIteration;
            }
            
            
            
            inline void setHasTriggeredEraseForNextIteration(const bool& hasTriggeredEraseForNextIteration) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _hasTriggeredEraseForNextIteration = hasTriggeredEraseForNextIteration;
            }
            
            
            
            inline bool getHasChangedVertexOrCellState() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _hasChangedVertexOrCellState;
            }
            
            
            
            inline void setHasChangedVertexOrCellState(const bool& hasChangedVertexOrCellState) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _hasChangedVertexOrCellState = hasChangedVertexOrCellState;
            }
            
            
            
            inline bool getIsTraversalInverted() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _isTraversalInverted;
            }
            
            
            
            inline void setIsTraversalInverted(const bool& isTraversalInverted) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _isTraversalInverted = isTraversalInverted;
            }
            
            
            
            inline bool getReduceStateAndCell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _reduceStateAndCell;
            }
            
            
            
            inline void setReduceStateAndCell(const bool& reduceStateAndCell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _reduceStateAndCell = reduceStateAndCell;
            }
            
            
            
            inline bool getCouldNotEraseDueToDecompositionFlag() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _couldNotEraseDueToDecompositionFlag;
            }
            
            
            
            inline void setCouldNotEraseDueToDecompositionFlag(const bool& couldNotEraseDueToDecompositionFlag) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _couldNotEraseDueToDecompositionFlag = couldNotEraseDueToDecompositionFlag;
            }
            
            
            
            inline bool getSubWorkerIsInvolvedInJoinOrFork() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _subWorkerIsInvolvedInJoinOrFork;
            }
            
            
            
            inline void setSubWorkerIsInvolvedInJoinOrFork(const bool& subWorkerIsInvolvedInJoinOrFork) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _subWorkerIsInvolvedInJoinOrFork = subWorkerIsInvolvedInJoinOrFork;
            }
            
            
            
         };
         
      private: 
         PersistentRecords _persistentRecords;
         
      public:
         /**
          * Generated
          */
         State();
         
         /**
          * Generated
          */
         State(const PersistentRecords& persistentRecords);
         
         /**
          * Generated
          */
         State(const int& additionalLevelsForPredefinedRefinement, const bool& isInitializing, const bool& initialRefinmentTriggered, const int& unknownsPerSubcell, const int& auxiliarFieldsPerSubcell, const tarch::la::Vector<DIMENSIONS,double>& initialMinimalMeshWidth, const tarch::la::Vector<DIMENSIONS,int>& defaultSubdivisionFactor, const int& defaultGhostWidthLayer, const double& initialTimestepSize, const bool& useDimensionalSplittingOptimization, const double& globalTimestepEndTime, const bool& allPatchesEvolvedToGlobalTimestep, const tarch::la::Vector<DIMENSIONS,double>& domainOffset, const tarch::la::Vector<DIMENSIONS,double>& domainSize, const int& plotNumber, const int& subPlotNumber, const double& startMaximumGlobalTimeInterval, const double& endMaximumGlobalTimeInterval, const double& startMinimumGlobalTimeInterval, const double& endMinimumGlobalTimeInterval, const double& minimalTimestep, const double& totalNumberOfCellUpdates, const tarch::la::Vector<DIMENSIONS,double>& minMeshWidth, const tarch::la::Vector<DIMENSIONS,double>& maxMeshWidth, const double& numberOfInnerVertices, const double& numberOfBoundaryVertices, const double& numberOfOuterVertices, const double& numberOfInnerCells, const double& numberOfOuterCells, const double& numberOfInnerLeafVertices, const double& numberOfBoundaryLeafVertices, const double& numberOfOuterLeafVertices, const double& numberOfInnerLeafCells, const double& numberOfOuterLeafCells, const int& maxLevel, const bool& hasRefined, const bool& hasTriggeredRefinementForNextIteration, const bool& hasErased, const bool& hasTriggeredEraseForNextIteration, const bool& hasChangedVertexOrCellState, const bool& isTraversalInverted, const bool& reduceStateAndCell, const bool& couldNotEraseDueToDecompositionFlag, const bool& subWorkerIsInvolvedInJoinOrFork);
         
         /**
          * Generated
          */
         virtual ~State();
         
         
         inline int getAdditionalLevelsForPredefinedRefinement() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._additionalLevelsForPredefinedRefinement;
         }
         
         
         
         inline void setAdditionalLevelsForPredefinedRefinement(const int& additionalLevelsForPredefinedRefinement) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._additionalLevelsForPredefinedRefinement = additionalLevelsForPredefinedRefinement;
         }
         
         
         
         inline bool getIsInitializing() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._isInitializing;
         }
         
         
         
         inline void setIsInitializing(const bool& isInitializing) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._isInitializing = isInitializing;
         }
         
         
         
         inline bool getInitialRefinmentTriggered() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._initialRefinmentTriggered;
         }
         
         
         
         inline void setInitialRefinmentTriggered(const bool& initialRefinmentTriggered) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._initialRefinmentTriggered = initialRefinmentTriggered;
         }
         
         
         
         inline int getUnknownsPerSubcell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._unknownsPerSubcell;
         }
         
         
         
         inline void setUnknownsPerSubcell(const int& unknownsPerSubcell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._unknownsPerSubcell = unknownsPerSubcell;
         }
         
         
         
         inline int getAuxiliarFieldsPerSubcell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._auxiliarFieldsPerSubcell;
         }
         
         
         
         inline void setAuxiliarFieldsPerSubcell(const int& auxiliarFieldsPerSubcell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._auxiliarFieldsPerSubcell = auxiliarFieldsPerSubcell;
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline tarch::la::Vector<DIMENSIONS,double> getInitialMinimalMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._initialMinimalMeshWidth;
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline void setInitialMinimalMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& initialMinimalMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._initialMinimalMeshWidth = (initialMinimalMeshWidth);
         }
         
         
         
         inline double getInitialMinimalMeshWidth(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            return _persistentRecords._initialMinimalMeshWidth[elementIndex];
            
         }
         
         
         
         inline void setInitialMinimalMeshWidth(int elementIndex, const double& initialMinimalMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            _persistentRecords._initialMinimalMeshWidth[elementIndex]= initialMinimalMeshWidth;
            
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline tarch::la::Vector<DIMENSIONS,int> getDefaultSubdivisionFactor() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._defaultSubdivisionFactor;
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline void setDefaultSubdivisionFactor(const tarch::la::Vector<DIMENSIONS,int>& defaultSubdivisionFactor) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._defaultSubdivisionFactor = (defaultSubdivisionFactor);
         }
         
         
         
         inline int getDefaultSubdivisionFactor(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            return _persistentRecords._defaultSubdivisionFactor[elementIndex];
            
         }
         
         
         
         inline void setDefaultSubdivisionFactor(int elementIndex, const int& defaultSubdivisionFactor) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            _persistentRecords._defaultSubdivisionFactor[elementIndex]= defaultSubdivisionFactor;
            
         }
         
         
         
         inline int getDefaultGhostWidthLayer() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._defaultGhostWidthLayer;
         }
         
         
         
         inline void setDefaultGhostWidthLayer(const int& defaultGhostWidthLayer) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._defaultGhostWidthLayer = defaultGhostWidthLayer;
         }
         
         
         
         inline double getInitialTimestepSize() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._initialTimestepSize;
         }
         
         
         
         inline void setInitialTimestepSize(const double& initialTimestepSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._initialTimestepSize = initialTimestepSize;
         }
         
         
         
         inline bool getUseDimensionalSplittingOptimization() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._useDimensionalSplittingOptimization;
         }
         
         
         
         inline void setUseDimensionalSplittingOptimization(const bool& useDimensionalSplittingOptimization) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._useDimensionalSplittingOptimization = useDimensionalSplittingOptimization;
         }
         
         
         
         inline double getGlobalTimestepEndTime() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._globalTimestepEndTime;
         }
         
         
         
         inline void setGlobalTimestepEndTime(const double& globalTimestepEndTime) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._globalTimestepEndTime = globalTimestepEndTime;
         }
         
         
         
         inline bool getAllPatchesEvolvedToGlobalTimestep() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._allPatchesEvolvedToGlobalTimestep;
         }
         
         
         
         inline void setAllPatchesEvolvedToGlobalTimestep(const bool& allPatchesEvolvedToGlobalTimestep) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._allPatchesEvolvedToGlobalTimestep = allPatchesEvolvedToGlobalTimestep;
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline tarch::la::Vector<DIMENSIONS,double> getDomainOffset() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._domainOffset;
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline void setDomainOffset(const tarch::la::Vector<DIMENSIONS,double>& domainOffset) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._domainOffset = (domainOffset);
         }
         
         
         
         inline double getDomainOffset(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            return _persistentRecords._domainOffset[elementIndex];
            
         }
         
         
         
         inline void setDomainOffset(int elementIndex, const double& domainOffset) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            _persistentRecords._domainOffset[elementIndex]= domainOffset;
            
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline tarch::la::Vector<DIMENSIONS,double> getDomainSize() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._domainSize;
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline void setDomainSize(const tarch::la::Vector<DIMENSIONS,double>& domainSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._domainSize = (domainSize);
         }
         
         
         
         inline double getDomainSize(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            return _persistentRecords._domainSize[elementIndex];
            
         }
         
         
         
         inline void setDomainSize(int elementIndex, const double& domainSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            _persistentRecords._domainSize[elementIndex]= domainSize;
            
         }
         
         
         
         inline int getPlotNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._plotNumber;
         }
         
         
         
         inline void setPlotNumber(const int& plotNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._plotNumber = plotNumber;
         }
         
         
         
         inline int getSubPlotNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._subPlotNumber;
         }
         
         
         
         inline void setSubPlotNumber(const int& subPlotNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._subPlotNumber = subPlotNumber;
         }
         
         
         
         inline double getStartMaximumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._startMaximumGlobalTimeInterval;
         }
         
         
         
         inline void setStartMaximumGlobalTimeInterval(const double& startMaximumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._startMaximumGlobalTimeInterval = startMaximumGlobalTimeInterval;
         }
         
         
         
         inline double getEndMaximumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._endMaximumGlobalTimeInterval;
         }
         
         
         
         inline void setEndMaximumGlobalTimeInterval(const double& endMaximumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._endMaximumGlobalTimeInterval = endMaximumGlobalTimeInterval;
         }
         
         
         
         inline double getStartMinimumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._startMinimumGlobalTimeInterval;
         }
         
         
         
         inline void setStartMinimumGlobalTimeInterval(const double& startMinimumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._startMinimumGlobalTimeInterval = startMinimumGlobalTimeInterval;
         }
         
         
         
         inline double getEndMinimumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._endMinimumGlobalTimeInterval;
         }
         
         
         
         inline void setEndMinimumGlobalTimeInterval(const double& endMinimumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._endMinimumGlobalTimeInterval = endMinimumGlobalTimeInterval;
         }
         
         
         
         inline double getMinimalTimestep() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._minimalTimestep;
         }
         
         
         
         inline void setMinimalTimestep(const double& minimalTimestep) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._minimalTimestep = minimalTimestep;
         }
         
         
         
         inline double getTotalNumberOfCellUpdates() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._totalNumberOfCellUpdates;
         }
         
         
         
         inline void setTotalNumberOfCellUpdates(const double& totalNumberOfCellUpdates) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._totalNumberOfCellUpdates = totalNumberOfCellUpdates;
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline tarch::la::Vector<DIMENSIONS,double> getMinMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._minMeshWidth;
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline void setMinMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& minMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._minMeshWidth = (minMeshWidth);
         }
         
         
         
         inline double getMinMeshWidth(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            return _persistentRecords._minMeshWidth[elementIndex];
            
         }
         
         
         
         inline void setMinMeshWidth(int elementIndex, const double& minMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            _persistentRecords._minMeshWidth[elementIndex]= minMeshWidth;
            
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline tarch::la::Vector<DIMENSIONS,double> getMaxMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._maxMeshWidth;
         }
         
         
         
         /**
          * Generated and optimized
          * 
          * If you realise a for loop using exclusively arrays (vectors) and compile 
          * with -DUseManualAlignment you may add 
          * \code
          #pragma vector aligned
          #pragma simd
          \endcode to this for loop to enforce your compiler to use SSE/AVX.
          * 
          * The alignment is tied to the unpacked records, i.e. for packed class
          * variants the machine's natural alignment is switched off to recude the  
          * memory footprint. Do not use any SSE/AVX operations or 
          * vectorisation on the result for the packed variants, as the data is misaligned. 
          * If you rely on vectorisation, convert the underlying record 
          * into the unpacked version first. 
          * 
          * @see convert()
          */
         inline void setMaxMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& maxMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._maxMeshWidth = (maxMeshWidth);
         }
         
         
         
         inline double getMaxMeshWidth(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            return _persistentRecords._maxMeshWidth[elementIndex];
            
         }
         
         
         
         inline void setMaxMeshWidth(int elementIndex, const double& maxMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            assertion(elementIndex>=0);
            assertion(elementIndex<DIMENSIONS);
            _persistentRecords._maxMeshWidth[elementIndex]= maxMeshWidth;
            
         }
         
         
         
         inline double getNumberOfInnerVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._numberOfInnerVertices;
         }
         
         
         
         inline void setNumberOfInnerVertices(const double& numberOfInnerVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._numberOfInnerVertices = numberOfInnerVertices;
         }
         
         
         
         inline double getNumberOfBoundaryVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._numberOfBoundaryVertices;
         }
         
         
         
         inline void setNumberOfBoundaryVertices(const double& numberOfBoundaryVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._numberOfBoundaryVertices = numberOfBoundaryVertices;
         }
         
         
         
         inline double getNumberOfOuterVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._numberOfOuterVertices;
         }
         
         
         
         inline void setNumberOfOuterVertices(const double& numberOfOuterVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._numberOfOuterVertices = numberOfOuterVertices;
         }
         
         
         
         inline double getNumberOfInnerCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._numberOfInnerCells;
         }
         
         
         
         inline void setNumberOfInnerCells(const double& numberOfInnerCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._numberOfInnerCells = numberOfInnerCells;
         }
         
         
         
         inline double getNumberOfOuterCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._numberOfOuterCells;
         }
         
         
         
         inline void setNumberOfOuterCells(const double& numberOfOuterCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._numberOfOuterCells = numberOfOuterCells;
         }
         
         
         
         inline double getNumberOfInnerLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._numberOfInnerLeafVertices;
         }
         
         
         
         inline void setNumberOfInnerLeafVertices(const double& numberOfInnerLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._numberOfInnerLeafVertices = numberOfInnerLeafVertices;
         }
         
         
         
         inline double getNumberOfBoundaryLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._numberOfBoundaryLeafVertices;
         }
         
         
         
         inline void setNumberOfBoundaryLeafVertices(const double& numberOfBoundaryLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._numberOfBoundaryLeafVertices = numberOfBoundaryLeafVertices;
         }
         
         
         
         inline double getNumberOfOuterLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._numberOfOuterLeafVertices;
         }
         
         
         
         inline void setNumberOfOuterLeafVertices(const double& numberOfOuterLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._numberOfOuterLeafVertices = numberOfOuterLeafVertices;
         }
         
         
         
         inline double getNumberOfInnerLeafCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._numberOfInnerLeafCells;
         }
         
         
         
         inline void setNumberOfInnerLeafCells(const double& numberOfInnerLeafCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._numberOfInnerLeafCells = numberOfInnerLeafCells;
         }
         
         
         
         inline double getNumberOfOuterLeafCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._numberOfOuterLeafCells;
         }
         
         
         
         inline void setNumberOfOuterLeafCells(const double& numberOfOuterLeafCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._numberOfOuterLeafCells = numberOfOuterLeafCells;
         }
         
         
         
         inline int getMaxLevel() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._maxLevel;
         }
         
         
         
         inline void setMaxLevel(const int& maxLevel) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._maxLevel = maxLevel;
         }
         
         
         
         inline bool getHasRefined() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._hasRefined;
         }
         
         
         
         inline void setHasRefined(const bool& hasRefined) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._hasRefined = hasRefined;
         }
         
         
         
         inline bool getHasTriggeredRefinementForNextIteration() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._hasTriggeredRefinementForNextIteration;
         }
         
         
         
         inline void setHasTriggeredRefinementForNextIteration(const bool& hasTriggeredRefinementForNextIteration) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._hasTriggeredRefinementForNextIteration = hasTriggeredRefinementForNextIteration;
         }
         
         
         
         inline bool getHasErased() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._hasErased;
         }
         
         
         
         inline void setHasErased(const bool& hasErased) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._hasErased = hasErased;
         }
         
         
         
         inline bool getHasTriggeredEraseForNextIteration() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._hasTriggeredEraseForNextIteration;
         }
         
         
         
         inline void setHasTriggeredEraseForNextIteration(const bool& hasTriggeredEraseForNextIteration) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._hasTriggeredEraseForNextIteration = hasTriggeredEraseForNextIteration;
         }
         
         
         
         inline bool getHasChangedVertexOrCellState() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._hasChangedVertexOrCellState;
         }
         
         
         
         inline void setHasChangedVertexOrCellState(const bool& hasChangedVertexOrCellState) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._hasChangedVertexOrCellState = hasChangedVertexOrCellState;
         }
         
         
         
         inline bool getIsTraversalInverted() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._isTraversalInverted;
         }
         
         
         
         inline void setIsTraversalInverted(const bool& isTraversalInverted) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._isTraversalInverted = isTraversalInverted;
         }
         
         
         
         inline bool getReduceStateAndCell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._reduceStateAndCell;
         }
         
         
         
         inline void setReduceStateAndCell(const bool& reduceStateAndCell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._reduceStateAndCell = reduceStateAndCell;
         }
         
         
         
         inline bool getCouldNotEraseDueToDecompositionFlag() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._couldNotEraseDueToDecompositionFlag;
         }
         
         
         
         inline void setCouldNotEraseDueToDecompositionFlag(const bool& couldNotEraseDueToDecompositionFlag) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._couldNotEraseDueToDecompositionFlag = couldNotEraseDueToDecompositionFlag;
         }
         
         
         
         inline bool getSubWorkerIsInvolvedInJoinOrFork() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            return _persistentRecords._subWorkerIsInvolvedInJoinOrFork;
         }
         
         
         
         inline void setSubWorkerIsInvolvedInJoinOrFork(const bool& subWorkerIsInvolvedInJoinOrFork) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
            _persistentRecords._subWorkerIsInvolvedInJoinOrFork = subWorkerIsInvolvedInJoinOrFork;
         }
         
         
         /**
          * Generated
          */
         std::string toString() const;
         
         /**
          * Generated
          */
         void toString(std::ostream& out) const;
         
         
         PersistentRecords getPersistentRecords() const;
         /**
          * Generated
          */
         StatePacked convert() const;
         
         
      #ifdef Parallel
         protected:
            static tarch::logging::Log _log;
            
            int _senderDestinationRank;
            
         public:
            
            /**
             * Global that represents the mpi datatype.
             * There are two variants: Datatype identifies only those attributes marked with
             * parallelise. FullDatatype instead identifies the whole record with all fields.
             */
            static MPI_Datatype Datatype;
            static MPI_Datatype FullDatatype;
            
            /**
             * Initializes the data type for the mpi operations. Has to be called
             * before the very first send or receive operation is called.
             */
            static void initDatatype();
            
            static void shutdownDatatype();
            
            void send(int destination, int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
            
            void receive(int source, int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
            
            static bool isMessageInQueue(int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
            
            int getSenderRank() const;
            
      #endif
         
      };
      
      #ifndef DaStGenPackedPadding
        #define DaStGenPackedPadding 1      // 32 bit version
        // #define DaStGenPackedPadding 2   // 64 bit version
      #endif
      
      
      #ifdef PackedRecords
         #pragma pack (push, DaStGenPackedPadding)
      #endif
      
      /**
       * @author This class is generated by DaStGen
       * 		   DataStructureGenerator (DaStGen)
       * 		   2007-2009 Wolfgang Eckhardt
       * 		   2012      Tobias Weinzierl
       *
       * 		   build date: 12-04-2013 09:18
       *
       * @date   18/07/2013 13:56
       */
      class peanoclaw::records::StatePacked { 
         
         public:
            
            struct PersistentRecords {
               int _additionalLevelsForPredefinedRefinement;
               bool _isInitializing;
               bool _initialRefinmentTriggered;
               int _unknownsPerSubcell;
               int _auxiliarFieldsPerSubcell;
               tarch::la::Vector<DIMENSIONS,double> _initialMinimalMeshWidth;
               tarch::la::Vector<DIMENSIONS,int> _defaultSubdivisionFactor;
               int _defaultGhostWidthLayer;
               double _initialTimestepSize;
               bool _useDimensionalSplittingOptimization;
               double _globalTimestepEndTime;
               tarch::la::Vector<DIMENSIONS,double> _domainOffset;
               tarch::la::Vector<DIMENSIONS,double> _domainSize;
               int _plotNumber;
               int _subPlotNumber;
               double _startMaximumGlobalTimeInterval;
               double _endMaximumGlobalTimeInterval;
               double _startMinimumGlobalTimeInterval;
               double _endMinimumGlobalTimeInterval;
               double _minimalTimestep;
               double _totalNumberOfCellUpdates;
               tarch::la::Vector<DIMENSIONS,double> _minMeshWidth;
               tarch::la::Vector<DIMENSIONS,double> _maxMeshWidth;
               double _numberOfInnerVertices;
               double _numberOfBoundaryVertices;
               double _numberOfOuterVertices;
               double _numberOfInnerCells;
               double _numberOfOuterCells;
               double _numberOfInnerLeafVertices;
               double _numberOfBoundaryLeafVertices;
               double _numberOfOuterLeafVertices;
               double _numberOfInnerLeafCells;
               double _numberOfOuterLeafCells;
               int _maxLevel;
               bool _isTraversalInverted;
               
               /** mapping of records:
               || Member 	|| startbit 	|| length
                |  allPatchesEvolvedToGlobalTimestep	| startbit 0	| #bits 1
                |  hasRefined	| startbit 1	| #bits 1
                |  hasTriggeredRefinementForNextIteration	| startbit 2	| #bits 1
                |  hasErased	| startbit 3	| #bits 1
                |  hasTriggeredEraseForNextIteration	| startbit 4	| #bits 1
                |  hasChangedVertexOrCellState	| startbit 5	| #bits 1
                |  reduceStateAndCell	| startbit 6	| #bits 1
                |  couldNotEraseDueToDecompositionFlag	| startbit 7	| #bits 1
                |  subWorkerIsInvolvedInJoinOrFork	| startbit 8	| #bits 1
                */
               short int _packedRecords0;
               
               /**
                * Generated
                */
               PersistentRecords();
               
               /**
                * Generated
                */
               PersistentRecords(const int& additionalLevelsForPredefinedRefinement, const bool& isInitializing, const bool& initialRefinmentTriggered, const int& unknownsPerSubcell, const int& auxiliarFieldsPerSubcell, const tarch::la::Vector<DIMENSIONS,double>& initialMinimalMeshWidth, const tarch::la::Vector<DIMENSIONS,int>& defaultSubdivisionFactor, const int& defaultGhostWidthLayer, const double& initialTimestepSize, const bool& useDimensionalSplittingOptimization, const double& globalTimestepEndTime, const bool& allPatchesEvolvedToGlobalTimestep, const tarch::la::Vector<DIMENSIONS,double>& domainOffset, const tarch::la::Vector<DIMENSIONS,double>& domainSize, const int& plotNumber, const int& subPlotNumber, const double& startMaximumGlobalTimeInterval, const double& endMaximumGlobalTimeInterval, const double& startMinimumGlobalTimeInterval, const double& endMinimumGlobalTimeInterval, const double& minimalTimestep, const double& totalNumberOfCellUpdates, const tarch::la::Vector<DIMENSIONS,double>& minMeshWidth, const tarch::la::Vector<DIMENSIONS,double>& maxMeshWidth, const double& numberOfInnerVertices, const double& numberOfBoundaryVertices, const double& numberOfOuterVertices, const double& numberOfInnerCells, const double& numberOfOuterCells, const double& numberOfInnerLeafVertices, const double& numberOfBoundaryLeafVertices, const double& numberOfOuterLeafVertices, const double& numberOfInnerLeafCells, const double& numberOfOuterLeafCells, const int& maxLevel, const bool& hasRefined, const bool& hasTriggeredRefinementForNextIteration, const bool& hasErased, const bool& hasTriggeredEraseForNextIteration, const bool& hasChangedVertexOrCellState, const bool& isTraversalInverted, const bool& reduceStateAndCell, const bool& couldNotEraseDueToDecompositionFlag, const bool& subWorkerIsInvolvedInJoinOrFork);
               
               
               inline int getAdditionalLevelsForPredefinedRefinement() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _additionalLevelsForPredefinedRefinement;
               }
               
               
               
               inline void setAdditionalLevelsForPredefinedRefinement(const int& additionalLevelsForPredefinedRefinement) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _additionalLevelsForPredefinedRefinement = additionalLevelsForPredefinedRefinement;
               }
               
               
               
               inline bool getIsInitializing() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _isInitializing;
               }
               
               
               
               inline void setIsInitializing(const bool& isInitializing) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _isInitializing = isInitializing;
               }
               
               
               
               inline bool getInitialRefinmentTriggered() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _initialRefinmentTriggered;
               }
               
               
               
               inline void setInitialRefinmentTriggered(const bool& initialRefinmentTriggered) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _initialRefinmentTriggered = initialRefinmentTriggered;
               }
               
               
               
               inline int getUnknownsPerSubcell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _unknownsPerSubcell;
               }
               
               
               
               inline void setUnknownsPerSubcell(const int& unknownsPerSubcell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _unknownsPerSubcell = unknownsPerSubcell;
               }
               
               
               
               inline int getAuxiliarFieldsPerSubcell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _auxiliarFieldsPerSubcell;
               }
               
               
               
               inline void setAuxiliarFieldsPerSubcell(const int& auxiliarFieldsPerSubcell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _auxiliarFieldsPerSubcell = auxiliarFieldsPerSubcell;
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline tarch::la::Vector<DIMENSIONS,double> getInitialMinimalMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _initialMinimalMeshWidth;
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline void setInitialMinimalMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& initialMinimalMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _initialMinimalMeshWidth = (initialMinimalMeshWidth);
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline tarch::la::Vector<DIMENSIONS,int> getDefaultSubdivisionFactor() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _defaultSubdivisionFactor;
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline void setDefaultSubdivisionFactor(const tarch::la::Vector<DIMENSIONS,int>& defaultSubdivisionFactor) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _defaultSubdivisionFactor = (defaultSubdivisionFactor);
               }
               
               
               
               inline int getDefaultGhostWidthLayer() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _defaultGhostWidthLayer;
               }
               
               
               
               inline void setDefaultGhostWidthLayer(const int& defaultGhostWidthLayer) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _defaultGhostWidthLayer = defaultGhostWidthLayer;
               }
               
               
               
               inline double getInitialTimestepSize() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _initialTimestepSize;
               }
               
               
               
               inline void setInitialTimestepSize(const double& initialTimestepSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _initialTimestepSize = initialTimestepSize;
               }
               
               
               
               inline bool getUseDimensionalSplittingOptimization() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _useDimensionalSplittingOptimization;
               }
               
               
               
               inline void setUseDimensionalSplittingOptimization(const bool& useDimensionalSplittingOptimization) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _useDimensionalSplittingOptimization = useDimensionalSplittingOptimization;
               }
               
               
               
               inline double getGlobalTimestepEndTime() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _globalTimestepEndTime;
               }
               
               
               
               inline void setGlobalTimestepEndTime(const double& globalTimestepEndTime) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _globalTimestepEndTime = globalTimestepEndTime;
               }
               
               
               
               inline bool getAllPatchesEvolvedToGlobalTimestep() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  short int mask = 1 << (0);
   short int tmp = static_cast<short int>(_packedRecords0 & mask);
   return (tmp != 0);
               }
               
               
               
               inline void setAllPatchesEvolvedToGlobalTimestep(const bool& allPatchesEvolvedToGlobalTimestep) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  short int mask = 1 << (0);
   _packedRecords0 = static_cast<short int>( allPatchesEvolvedToGlobalTimestep ? (_packedRecords0 | mask) : (_packedRecords0 & ~mask));
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline tarch::la::Vector<DIMENSIONS,double> getDomainOffset() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _domainOffset;
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline void setDomainOffset(const tarch::la::Vector<DIMENSIONS,double>& domainOffset) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _domainOffset = (domainOffset);
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline tarch::la::Vector<DIMENSIONS,double> getDomainSize() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _domainSize;
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline void setDomainSize(const tarch::la::Vector<DIMENSIONS,double>& domainSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _domainSize = (domainSize);
               }
               
               
               
               inline int getPlotNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _plotNumber;
               }
               
               
               
               inline void setPlotNumber(const int& plotNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _plotNumber = plotNumber;
               }
               
               
               
               inline int getSubPlotNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _subPlotNumber;
               }
               
               
               
               inline void setSubPlotNumber(const int& subPlotNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _subPlotNumber = subPlotNumber;
               }
               
               
               
               inline double getStartMaximumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _startMaximumGlobalTimeInterval;
               }
               
               
               
               inline void setStartMaximumGlobalTimeInterval(const double& startMaximumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _startMaximumGlobalTimeInterval = startMaximumGlobalTimeInterval;
               }
               
               
               
               inline double getEndMaximumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _endMaximumGlobalTimeInterval;
               }
               
               
               
               inline void setEndMaximumGlobalTimeInterval(const double& endMaximumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _endMaximumGlobalTimeInterval = endMaximumGlobalTimeInterval;
               }
               
               
               
               inline double getStartMinimumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _startMinimumGlobalTimeInterval;
               }
               
               
               
               inline void setStartMinimumGlobalTimeInterval(const double& startMinimumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _startMinimumGlobalTimeInterval = startMinimumGlobalTimeInterval;
               }
               
               
               
               inline double getEndMinimumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _endMinimumGlobalTimeInterval;
               }
               
               
               
               inline void setEndMinimumGlobalTimeInterval(const double& endMinimumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _endMinimumGlobalTimeInterval = endMinimumGlobalTimeInterval;
               }
               
               
               
               inline double getMinimalTimestep() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _minimalTimestep;
               }
               
               
               
               inline void setMinimalTimestep(const double& minimalTimestep) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _minimalTimestep = minimalTimestep;
               }
               
               
               
               inline double getTotalNumberOfCellUpdates() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _totalNumberOfCellUpdates;
               }
               
               
               
               inline void setTotalNumberOfCellUpdates(const double& totalNumberOfCellUpdates) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _totalNumberOfCellUpdates = totalNumberOfCellUpdates;
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline tarch::la::Vector<DIMENSIONS,double> getMinMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _minMeshWidth;
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline void setMinMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& minMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _minMeshWidth = (minMeshWidth);
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline tarch::la::Vector<DIMENSIONS,double> getMaxMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _maxMeshWidth;
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline void setMaxMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& maxMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _maxMeshWidth = (maxMeshWidth);
               }
               
               
               
               inline double getNumberOfInnerVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _numberOfInnerVertices;
               }
               
               
               
               inline void setNumberOfInnerVertices(const double& numberOfInnerVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _numberOfInnerVertices = numberOfInnerVertices;
               }
               
               
               
               inline double getNumberOfBoundaryVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _numberOfBoundaryVertices;
               }
               
               
               
               inline void setNumberOfBoundaryVertices(const double& numberOfBoundaryVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _numberOfBoundaryVertices = numberOfBoundaryVertices;
               }
               
               
               
               inline double getNumberOfOuterVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _numberOfOuterVertices;
               }
               
               
               
               inline void setNumberOfOuterVertices(const double& numberOfOuterVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _numberOfOuterVertices = numberOfOuterVertices;
               }
               
               
               
               inline double getNumberOfInnerCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _numberOfInnerCells;
               }
               
               
               
               inline void setNumberOfInnerCells(const double& numberOfInnerCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _numberOfInnerCells = numberOfInnerCells;
               }
               
               
               
               inline double getNumberOfOuterCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _numberOfOuterCells;
               }
               
               
               
               inline void setNumberOfOuterCells(const double& numberOfOuterCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _numberOfOuterCells = numberOfOuterCells;
               }
               
               
               
               inline double getNumberOfInnerLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _numberOfInnerLeafVertices;
               }
               
               
               
               inline void setNumberOfInnerLeafVertices(const double& numberOfInnerLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _numberOfInnerLeafVertices = numberOfInnerLeafVertices;
               }
               
               
               
               inline double getNumberOfBoundaryLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _numberOfBoundaryLeafVertices;
               }
               
               
               
               inline void setNumberOfBoundaryLeafVertices(const double& numberOfBoundaryLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _numberOfBoundaryLeafVertices = numberOfBoundaryLeafVertices;
               }
               
               
               
               inline double getNumberOfOuterLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _numberOfOuterLeafVertices;
               }
               
               
               
               inline void setNumberOfOuterLeafVertices(const double& numberOfOuterLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _numberOfOuterLeafVertices = numberOfOuterLeafVertices;
               }
               
               
               
               inline double getNumberOfInnerLeafCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _numberOfInnerLeafCells;
               }
               
               
               
               inline void setNumberOfInnerLeafCells(const double& numberOfInnerLeafCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _numberOfInnerLeafCells = numberOfInnerLeafCells;
               }
               
               
               
               inline double getNumberOfOuterLeafCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _numberOfOuterLeafCells;
               }
               
               
               
               inline void setNumberOfOuterLeafCells(const double& numberOfOuterLeafCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _numberOfOuterLeafCells = numberOfOuterLeafCells;
               }
               
               
               
               inline int getMaxLevel() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _maxLevel;
               }
               
               
               
               inline void setMaxLevel(const int& maxLevel) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _maxLevel = maxLevel;
               }
               
               
               
               inline bool getHasRefined() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  short int mask = 1 << (1);
   short int tmp = static_cast<short int>(_packedRecords0 & mask);
   return (tmp != 0);
               }
               
               
               
               inline void setHasRefined(const bool& hasRefined) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  short int mask = 1 << (1);
   _packedRecords0 = static_cast<short int>( hasRefined ? (_packedRecords0 | mask) : (_packedRecords0 & ~mask));
               }
               
               
               
               inline bool getHasTriggeredRefinementForNextIteration() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  short int mask = 1 << (2);
   short int tmp = static_cast<short int>(_packedRecords0 & mask);
   return (tmp != 0);
               }
               
               
               
               inline void setHasTriggeredRefinementForNextIteration(const bool& hasTriggeredRefinementForNextIteration) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  short int mask = 1 << (2);
   _packedRecords0 = static_cast<short int>( hasTriggeredRefinementForNextIteration ? (_packedRecords0 | mask) : (_packedRecords0 & ~mask));
               }
               
               
               
               inline bool getHasErased() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  short int mask = 1 << (3);
   short int tmp = static_cast<short int>(_packedRecords0 & mask);
   return (tmp != 0);
               }
               
               
               
               inline void setHasErased(const bool& hasErased) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  short int mask = 1 << (3);
   _packedRecords0 = static_cast<short int>( hasErased ? (_packedRecords0 | mask) : (_packedRecords0 & ~mask));
               }
               
               
               
               inline bool getHasTriggeredEraseForNextIteration() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  short int mask = 1 << (4);
   short int tmp = static_cast<short int>(_packedRecords0 & mask);
   return (tmp != 0);
               }
               
               
               
               inline void setHasTriggeredEraseForNextIteration(const bool& hasTriggeredEraseForNextIteration) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  short int mask = 1 << (4);
   _packedRecords0 = static_cast<short int>( hasTriggeredEraseForNextIteration ? (_packedRecords0 | mask) : (_packedRecords0 & ~mask));
               }
               
               
               
               inline bool getHasChangedVertexOrCellState() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  short int mask = 1 << (5);
   short int tmp = static_cast<short int>(_packedRecords0 & mask);
   return (tmp != 0);
               }
               
               
               
               inline void setHasChangedVertexOrCellState(const bool& hasChangedVertexOrCellState) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  short int mask = 1 << (5);
   _packedRecords0 = static_cast<short int>( hasChangedVertexOrCellState ? (_packedRecords0 | mask) : (_packedRecords0 & ~mask));
               }
               
               
               
               inline bool getIsTraversalInverted() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _isTraversalInverted;
               }
               
               
               
               inline void setIsTraversalInverted(const bool& isTraversalInverted) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _isTraversalInverted = isTraversalInverted;
               }
               
               
               
               inline bool getReduceStateAndCell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  short int mask = 1 << (6);
   short int tmp = static_cast<short int>(_packedRecords0 & mask);
   return (tmp != 0);
               }
               
               
               
               inline void setReduceStateAndCell(const bool& reduceStateAndCell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  short int mask = 1 << (6);
   _packedRecords0 = static_cast<short int>( reduceStateAndCell ? (_packedRecords0 | mask) : (_packedRecords0 & ~mask));
               }
               
               
               
               inline bool getCouldNotEraseDueToDecompositionFlag() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  short int mask = 1 << (7);
   short int tmp = static_cast<short int>(_packedRecords0 & mask);
   return (tmp != 0);
               }
               
               
               
               inline void setCouldNotEraseDueToDecompositionFlag(const bool& couldNotEraseDueToDecompositionFlag) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  short int mask = 1 << (7);
   _packedRecords0 = static_cast<short int>( couldNotEraseDueToDecompositionFlag ? (_packedRecords0 | mask) : (_packedRecords0 & ~mask));
               }
               
               
               
               inline bool getSubWorkerIsInvolvedInJoinOrFork() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  short int mask = 1 << (8);
   short int tmp = static_cast<short int>(_packedRecords0 & mask);
   return (tmp != 0);
               }
               
               
               
               inline void setSubWorkerIsInvolvedInJoinOrFork(const bool& subWorkerIsInvolvedInJoinOrFork) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  short int mask = 1 << (8);
   _packedRecords0 = static_cast<short int>( subWorkerIsInvolvedInJoinOrFork ? (_packedRecords0 | mask) : (_packedRecords0 & ~mask));
               }
               
               
               
            };
            
         private: 
            PersistentRecords _persistentRecords;
            
         public:
            /**
             * Generated
             */
            StatePacked();
            
            /**
             * Generated
             */
            StatePacked(const PersistentRecords& persistentRecords);
            
            /**
             * Generated
             */
            StatePacked(const int& additionalLevelsForPredefinedRefinement, const bool& isInitializing, const bool& initialRefinmentTriggered, const int& unknownsPerSubcell, const int& auxiliarFieldsPerSubcell, const tarch::la::Vector<DIMENSIONS,double>& initialMinimalMeshWidth, const tarch::la::Vector<DIMENSIONS,int>& defaultSubdivisionFactor, const int& defaultGhostWidthLayer, const double& initialTimestepSize, const bool& useDimensionalSplittingOptimization, const double& globalTimestepEndTime, const bool& allPatchesEvolvedToGlobalTimestep, const tarch::la::Vector<DIMENSIONS,double>& domainOffset, const tarch::la::Vector<DIMENSIONS,double>& domainSize, const int& plotNumber, const int& subPlotNumber, const double& startMaximumGlobalTimeInterval, const double& endMaximumGlobalTimeInterval, const double& startMinimumGlobalTimeInterval, const double& endMinimumGlobalTimeInterval, const double& minimalTimestep, const double& totalNumberOfCellUpdates, const tarch::la::Vector<DIMENSIONS,double>& minMeshWidth, const tarch::la::Vector<DIMENSIONS,double>& maxMeshWidth, const double& numberOfInnerVertices, const double& numberOfBoundaryVertices, const double& numberOfOuterVertices, const double& numberOfInnerCells, const double& numberOfOuterCells, const double& numberOfInnerLeafVertices, const double& numberOfBoundaryLeafVertices, const double& numberOfOuterLeafVertices, const double& numberOfInnerLeafCells, const double& numberOfOuterLeafCells, const int& maxLevel, const bool& hasRefined, const bool& hasTriggeredRefinementForNextIteration, const bool& hasErased, const bool& hasTriggeredEraseForNextIteration, const bool& hasChangedVertexOrCellState, const bool& isTraversalInverted, const bool& reduceStateAndCell, const bool& couldNotEraseDueToDecompositionFlag, const bool& subWorkerIsInvolvedInJoinOrFork);
            
            /**
             * Generated
             */
            virtual ~StatePacked();
            
            
            inline int getAdditionalLevelsForPredefinedRefinement() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._additionalLevelsForPredefinedRefinement;
            }
            
            
            
            inline void setAdditionalLevelsForPredefinedRefinement(const int& additionalLevelsForPredefinedRefinement) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._additionalLevelsForPredefinedRefinement = additionalLevelsForPredefinedRefinement;
            }
            
            
            
            inline bool getIsInitializing() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._isInitializing;
            }
            
            
            
            inline void setIsInitializing(const bool& isInitializing) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._isInitializing = isInitializing;
            }
            
            
            
            inline bool getInitialRefinmentTriggered() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._initialRefinmentTriggered;
            }
            
            
            
            inline void setInitialRefinmentTriggered(const bool& initialRefinmentTriggered) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._initialRefinmentTriggered = initialRefinmentTriggered;
            }
            
            
            
            inline int getUnknownsPerSubcell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._unknownsPerSubcell;
            }
            
            
            
            inline void setUnknownsPerSubcell(const int& unknownsPerSubcell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._unknownsPerSubcell = unknownsPerSubcell;
            }
            
            
            
            inline int getAuxiliarFieldsPerSubcell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._auxiliarFieldsPerSubcell;
            }
            
            
            
            inline void setAuxiliarFieldsPerSubcell(const int& auxiliarFieldsPerSubcell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._auxiliarFieldsPerSubcell = auxiliarFieldsPerSubcell;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline tarch::la::Vector<DIMENSIONS,double> getInitialMinimalMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._initialMinimalMeshWidth;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline void setInitialMinimalMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& initialMinimalMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._initialMinimalMeshWidth = (initialMinimalMeshWidth);
            }
            
            
            
            inline double getInitialMinimalMeshWidth(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               assertion(elementIndex>=0);
               assertion(elementIndex<DIMENSIONS);
               return _persistentRecords._initialMinimalMeshWidth[elementIndex];
               
            }
            
            
            
            inline void setInitialMinimalMeshWidth(int elementIndex, const double& initialMinimalMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               assertion(elementIndex>=0);
               assertion(elementIndex<DIMENSIONS);
               _persistentRecords._initialMinimalMeshWidth[elementIndex]= initialMinimalMeshWidth;
               
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline tarch::la::Vector<DIMENSIONS,int> getDefaultSubdivisionFactor() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._defaultSubdivisionFactor;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline void setDefaultSubdivisionFactor(const tarch::la::Vector<DIMENSIONS,int>& defaultSubdivisionFactor) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._defaultSubdivisionFactor = (defaultSubdivisionFactor);
            }
            
            
            
            inline int getDefaultSubdivisionFactor(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               assertion(elementIndex>=0);
               assertion(elementIndex<DIMENSIONS);
               return _persistentRecords._defaultSubdivisionFactor[elementIndex];
               
            }
            
            
            
            inline void setDefaultSubdivisionFactor(int elementIndex, const int& defaultSubdivisionFactor) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               assertion(elementIndex>=0);
               assertion(elementIndex<DIMENSIONS);
               _persistentRecords._defaultSubdivisionFactor[elementIndex]= defaultSubdivisionFactor;
               
            }
            
            
            
            inline int getDefaultGhostWidthLayer() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._defaultGhostWidthLayer;
            }
            
            
            
            inline void setDefaultGhostWidthLayer(const int& defaultGhostWidthLayer) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._defaultGhostWidthLayer = defaultGhostWidthLayer;
            }
            
            
            
            inline double getInitialTimestepSize() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._initialTimestepSize;
            }
            
            
            
            inline void setInitialTimestepSize(const double& initialTimestepSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._initialTimestepSize = initialTimestepSize;
            }
            
            
            
            inline bool getUseDimensionalSplittingOptimization() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._useDimensionalSplittingOptimization;
            }
            
            
            
            inline void setUseDimensionalSplittingOptimization(const bool& useDimensionalSplittingOptimization) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._useDimensionalSplittingOptimization = useDimensionalSplittingOptimization;
            }
            
            
            
            inline double getGlobalTimestepEndTime() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._globalTimestepEndTime;
            }
            
            
            
            inline void setGlobalTimestepEndTime(const double& globalTimestepEndTime) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._globalTimestepEndTime = globalTimestepEndTime;
            }
            
            
            
            inline bool getAllPatchesEvolvedToGlobalTimestep() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               short int mask = 1 << (0);
   short int tmp = static_cast<short int>(_persistentRecords._packedRecords0 & mask);
   return (tmp != 0);
            }
            
            
            
            inline void setAllPatchesEvolvedToGlobalTimestep(const bool& allPatchesEvolvedToGlobalTimestep) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               short int mask = 1 << (0);
   _persistentRecords._packedRecords0 = static_cast<short int>( allPatchesEvolvedToGlobalTimestep ? (_persistentRecords._packedRecords0 | mask) : (_persistentRecords._packedRecords0 & ~mask));
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline tarch::la::Vector<DIMENSIONS,double> getDomainOffset() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._domainOffset;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline void setDomainOffset(const tarch::la::Vector<DIMENSIONS,double>& domainOffset) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._domainOffset = (domainOffset);
            }
            
            
            
            inline double getDomainOffset(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               assertion(elementIndex>=0);
               assertion(elementIndex<DIMENSIONS);
               return _persistentRecords._domainOffset[elementIndex];
               
            }
            
            
            
            inline void setDomainOffset(int elementIndex, const double& domainOffset) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               assertion(elementIndex>=0);
               assertion(elementIndex<DIMENSIONS);
               _persistentRecords._domainOffset[elementIndex]= domainOffset;
               
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline tarch::la::Vector<DIMENSIONS,double> getDomainSize() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._domainSize;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline void setDomainSize(const tarch::la::Vector<DIMENSIONS,double>& domainSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._domainSize = (domainSize);
            }
            
            
            
            inline double getDomainSize(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               assertion(elementIndex>=0);
               assertion(elementIndex<DIMENSIONS);
               return _persistentRecords._domainSize[elementIndex];
               
            }
            
            
            
            inline void setDomainSize(int elementIndex, const double& domainSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               assertion(elementIndex>=0);
               assertion(elementIndex<DIMENSIONS);
               _persistentRecords._domainSize[elementIndex]= domainSize;
               
            }
            
            
            
            inline int getPlotNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._plotNumber;
            }
            
            
            
            inline void setPlotNumber(const int& plotNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._plotNumber = plotNumber;
            }
            
            
            
            inline int getSubPlotNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._subPlotNumber;
            }
            
            
            
            inline void setSubPlotNumber(const int& subPlotNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._subPlotNumber = subPlotNumber;
            }
            
            
            
            inline double getStartMaximumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._startMaximumGlobalTimeInterval;
            }
            
            
            
            inline void setStartMaximumGlobalTimeInterval(const double& startMaximumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._startMaximumGlobalTimeInterval = startMaximumGlobalTimeInterval;
            }
            
            
            
            inline double getEndMaximumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._endMaximumGlobalTimeInterval;
            }
            
            
            
            inline void setEndMaximumGlobalTimeInterval(const double& endMaximumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._endMaximumGlobalTimeInterval = endMaximumGlobalTimeInterval;
            }
            
            
            
            inline double getStartMinimumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._startMinimumGlobalTimeInterval;
            }
            
            
            
            inline void setStartMinimumGlobalTimeInterval(const double& startMinimumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._startMinimumGlobalTimeInterval = startMinimumGlobalTimeInterval;
            }
            
            
            
            inline double getEndMinimumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._endMinimumGlobalTimeInterval;
            }
            
            
            
            inline void setEndMinimumGlobalTimeInterval(const double& endMinimumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._endMinimumGlobalTimeInterval = endMinimumGlobalTimeInterval;
            }
            
            
            
            inline double getMinimalTimestep() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._minimalTimestep;
            }
            
            
            
            inline void setMinimalTimestep(const double& minimalTimestep) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._minimalTimestep = minimalTimestep;
            }
            
            
            
            inline double getTotalNumberOfCellUpdates() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._totalNumberOfCellUpdates;
            }
            
            
            
            inline void setTotalNumberOfCellUpdates(const double& totalNumberOfCellUpdates) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._totalNumberOfCellUpdates = totalNumberOfCellUpdates;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline tarch::la::Vector<DIMENSIONS,double> getMinMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._minMeshWidth;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline void setMinMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& minMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._minMeshWidth = (minMeshWidth);
            }
            
            
            
            inline double getMinMeshWidth(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               assertion(elementIndex>=0);
               assertion(elementIndex<DIMENSIONS);
               return _persistentRecords._minMeshWidth[elementIndex];
               
            }
            
            
            
            inline void setMinMeshWidth(int elementIndex, const double& minMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               assertion(elementIndex>=0);
               assertion(elementIndex<DIMENSIONS);
               _persistentRecords._minMeshWidth[elementIndex]= minMeshWidth;
               
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline tarch::la::Vector<DIMENSIONS,double> getMaxMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._maxMeshWidth;
            }
            
            
            
            /**
             * Generated and optimized
             * 
             * If you realise a for loop using exclusively arrays (vectors) and compile 
             * with -DUseManualAlignment you may add 
             * \code
             #pragma vector aligned
             #pragma simd
             \endcode to this for loop to enforce your compiler to use SSE/AVX.
             * 
             * The alignment is tied to the unpacked records, i.e. for packed class
             * variants the machine's natural alignment is switched off to recude the  
             * memory footprint. Do not use any SSE/AVX operations or 
             * vectorisation on the result for the packed variants, as the data is misaligned. 
             * If you rely on vectorisation, convert the underlying record 
             * into the unpacked version first. 
             * 
             * @see convert()
             */
            inline void setMaxMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& maxMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._maxMeshWidth = (maxMeshWidth);
            }
            
            
            
            inline double getMaxMeshWidth(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               assertion(elementIndex>=0);
               assertion(elementIndex<DIMENSIONS);
               return _persistentRecords._maxMeshWidth[elementIndex];
               
            }
            
            
            
            inline void setMaxMeshWidth(int elementIndex, const double& maxMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               assertion(elementIndex>=0);
               assertion(elementIndex<DIMENSIONS);
               _persistentRecords._maxMeshWidth[elementIndex]= maxMeshWidth;
               
            }
            
            
            
            inline double getNumberOfInnerVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._numberOfInnerVertices;
            }
            
            
            
            inline void setNumberOfInnerVertices(const double& numberOfInnerVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._numberOfInnerVertices = numberOfInnerVertices;
            }
            
            
            
            inline double getNumberOfBoundaryVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._numberOfBoundaryVertices;
            }
            
            
            
            inline void setNumberOfBoundaryVertices(const double& numberOfBoundaryVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._numberOfBoundaryVertices = numberOfBoundaryVertices;
            }
            
            
            
            inline double getNumberOfOuterVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._numberOfOuterVertices;
            }
            
            
            
            inline void setNumberOfOuterVertices(const double& numberOfOuterVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._numberOfOuterVertices = numberOfOuterVertices;
            }
            
            
            
            inline double getNumberOfInnerCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._numberOfInnerCells;
            }
            
            
            
            inline void setNumberOfInnerCells(const double& numberOfInnerCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._numberOfInnerCells = numberOfInnerCells;
            }
            
            
            
            inline double getNumberOfOuterCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._numberOfOuterCells;
            }
            
            
            
            inline void setNumberOfOuterCells(const double& numberOfOuterCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._numberOfOuterCells = numberOfOuterCells;
            }
            
            
            
            inline double getNumberOfInnerLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._numberOfInnerLeafVertices;
            }
            
            
            
            inline void setNumberOfInnerLeafVertices(const double& numberOfInnerLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._numberOfInnerLeafVertices = numberOfInnerLeafVertices;
            }
            
            
            
            inline double getNumberOfBoundaryLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._numberOfBoundaryLeafVertices;
            }
            
            
            
            inline void setNumberOfBoundaryLeafVertices(const double& numberOfBoundaryLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._numberOfBoundaryLeafVertices = numberOfBoundaryLeafVertices;
            }
            
            
            
            inline double getNumberOfOuterLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._numberOfOuterLeafVertices;
            }
            
            
            
            inline void setNumberOfOuterLeafVertices(const double& numberOfOuterLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._numberOfOuterLeafVertices = numberOfOuterLeafVertices;
            }
            
            
            
            inline double getNumberOfInnerLeafCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._numberOfInnerLeafCells;
            }
            
            
            
            inline void setNumberOfInnerLeafCells(const double& numberOfInnerLeafCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._numberOfInnerLeafCells = numberOfInnerLeafCells;
            }
            
            
            
            inline double getNumberOfOuterLeafCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._numberOfOuterLeafCells;
            }
            
            
            
            inline void setNumberOfOuterLeafCells(const double& numberOfOuterLeafCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._numberOfOuterLeafCells = numberOfOuterLeafCells;
            }
            
            
            
            inline int getMaxLevel() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._maxLevel;
            }
            
            
            
            inline void setMaxLevel(const int& maxLevel) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._maxLevel = maxLevel;
            }
            
            
            
            inline bool getHasRefined() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               short int mask = 1 << (1);
   short int tmp = static_cast<short int>(_persistentRecords._packedRecords0 & mask);
   return (tmp != 0);
            }
            
            
            
            inline void setHasRefined(const bool& hasRefined) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               short int mask = 1 << (1);
   _persistentRecords._packedRecords0 = static_cast<short int>( hasRefined ? (_persistentRecords._packedRecords0 | mask) : (_persistentRecords._packedRecords0 & ~mask));
            }
            
            
            
            inline bool getHasTriggeredRefinementForNextIteration() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               short int mask = 1 << (2);
   short int tmp = static_cast<short int>(_persistentRecords._packedRecords0 & mask);
   return (tmp != 0);
            }
            
            
            
            inline void setHasTriggeredRefinementForNextIteration(const bool& hasTriggeredRefinementForNextIteration) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               short int mask = 1 << (2);
   _persistentRecords._packedRecords0 = static_cast<short int>( hasTriggeredRefinementForNextIteration ? (_persistentRecords._packedRecords0 | mask) : (_persistentRecords._packedRecords0 & ~mask));
            }
            
            
            
            inline bool getHasErased() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               short int mask = 1 << (3);
   short int tmp = static_cast<short int>(_persistentRecords._packedRecords0 & mask);
   return (tmp != 0);
            }
            
            
            
            inline void setHasErased(const bool& hasErased) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               short int mask = 1 << (3);
   _persistentRecords._packedRecords0 = static_cast<short int>( hasErased ? (_persistentRecords._packedRecords0 | mask) : (_persistentRecords._packedRecords0 & ~mask));
            }
            
            
            
            inline bool getHasTriggeredEraseForNextIteration() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               short int mask = 1 << (4);
   short int tmp = static_cast<short int>(_persistentRecords._packedRecords0 & mask);
   return (tmp != 0);
            }
            
            
            
            inline void setHasTriggeredEraseForNextIteration(const bool& hasTriggeredEraseForNextIteration) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               short int mask = 1 << (4);
   _persistentRecords._packedRecords0 = static_cast<short int>( hasTriggeredEraseForNextIteration ? (_persistentRecords._packedRecords0 | mask) : (_persistentRecords._packedRecords0 & ~mask));
            }
            
            
            
            inline bool getHasChangedVertexOrCellState() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               short int mask = 1 << (5);
   short int tmp = static_cast<short int>(_persistentRecords._packedRecords0 & mask);
   return (tmp != 0);
            }
            
            
            
            inline void setHasChangedVertexOrCellState(const bool& hasChangedVertexOrCellState) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               short int mask = 1 << (5);
   _persistentRecords._packedRecords0 = static_cast<short int>( hasChangedVertexOrCellState ? (_persistentRecords._packedRecords0 | mask) : (_persistentRecords._packedRecords0 & ~mask));
            }
            
            
            
            inline bool getIsTraversalInverted() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               return _persistentRecords._isTraversalInverted;
            }
            
            
            
            inline void setIsTraversalInverted(const bool& isTraversalInverted) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               _persistentRecords._isTraversalInverted = isTraversalInverted;
            }
            
            
            
            inline bool getReduceStateAndCell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               short int mask = 1 << (6);
   short int tmp = static_cast<short int>(_persistentRecords._packedRecords0 & mask);
   return (tmp != 0);
            }
            
            
            
            inline void setReduceStateAndCell(const bool& reduceStateAndCell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               short int mask = 1 << (6);
   _persistentRecords._packedRecords0 = static_cast<short int>( reduceStateAndCell ? (_persistentRecords._packedRecords0 | mask) : (_persistentRecords._packedRecords0 & ~mask));
            }
            
            
            
            inline bool getCouldNotEraseDueToDecompositionFlag() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               short int mask = 1 << (7);
   short int tmp = static_cast<short int>(_persistentRecords._packedRecords0 & mask);
   return (tmp != 0);
            }
            
            
            
            inline void setCouldNotEraseDueToDecompositionFlag(const bool& couldNotEraseDueToDecompositionFlag) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               short int mask = 1 << (7);
   _persistentRecords._packedRecords0 = static_cast<short int>( couldNotEraseDueToDecompositionFlag ? (_persistentRecords._packedRecords0 | mask) : (_persistentRecords._packedRecords0 & ~mask));
            }
            
            
            
            inline bool getSubWorkerIsInvolvedInJoinOrFork() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               short int mask = 1 << (8);
   short int tmp = static_cast<short int>(_persistentRecords._packedRecords0 & mask);
   return (tmp != 0);
            }
            
            
            
            inline void setSubWorkerIsInvolvedInJoinOrFork(const bool& subWorkerIsInvolvedInJoinOrFork) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
               short int mask = 1 << (8);
   _persistentRecords._packedRecords0 = static_cast<short int>( subWorkerIsInvolvedInJoinOrFork ? (_persistentRecords._packedRecords0 | mask) : (_persistentRecords._packedRecords0 & ~mask));
            }
            
            
            /**
             * Generated
             */
            std::string toString() const;
            
            /**
             * Generated
             */
            void toString(std::ostream& out) const;
            
            
            PersistentRecords getPersistentRecords() const;
            /**
             * Generated
             */
            State convert() const;
            
            
         #ifdef Parallel
            protected:
               static tarch::logging::Log _log;
               
               int _senderDestinationRank;
               
            public:
               
               /**
                * Global that represents the mpi datatype.
                * There are two variants: Datatype identifies only those attributes marked with
                * parallelise. FullDatatype instead identifies the whole record with all fields.
                */
               static MPI_Datatype Datatype;
               static MPI_Datatype FullDatatype;
               
               /**
                * Initializes the data type for the mpi operations. Has to be called
                * before the very first send or receive operation is called.
                */
               static void initDatatype();
               
               static void shutdownDatatype();
               
               void send(int destination, int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
               
               void receive(int source, int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
               
               static bool isMessageInQueue(int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
               
               int getSenderRank() const;
               
         #endif
            
         };
         
         #ifdef PackedRecords
         #pragma pack (pop)
         #endif
         
         
         
      #elif !defined(Parallel)
         /**
          * @author This class is generated by DaStGen
          * 		   DataStructureGenerator (DaStGen)
          * 		   2007-2009 Wolfgang Eckhardt
          * 		   2012      Tobias Weinzierl
          *
          * 		   build date: 12-04-2013 09:18
          *
          * @date   18/07/2013 13:56
          */
         class peanoclaw::records::State { 
            
            public:
               
               typedef peanoclaw::records::StatePacked Packed;
               
               struct PersistentRecords {
                  int _additionalLevelsForPredefinedRefinement;
                  bool _isInitializing;
                  bool _initialRefinmentTriggered;
                  int _unknownsPerSubcell;
                  int _auxiliarFieldsPerSubcell;
                  #ifdef UseManualAlignment
                  tarch::la::Vector<DIMENSIONS,double> _initialMinimalMeshWidth __attribute__((aligned(VectorisationAlignment)));
                  #else
                  tarch::la::Vector<DIMENSIONS,double> _initialMinimalMeshWidth;
                  #endif
                  #ifdef UseManualAlignment
                  tarch::la::Vector<DIMENSIONS,int> _defaultSubdivisionFactor __attribute__((aligned(VectorisationAlignment)));
                  #else
                  tarch::la::Vector<DIMENSIONS,int> _defaultSubdivisionFactor;
                  #endif
                  int _defaultGhostWidthLayer;
                  double _initialTimestepSize;
                  bool _useDimensionalSplittingOptimization;
                  double _globalTimestepEndTime;
                  bool _allPatchesEvolvedToGlobalTimestep;
                  #ifdef UseManualAlignment
                  tarch::la::Vector<DIMENSIONS,double> _domainOffset __attribute__((aligned(VectorisationAlignment)));
                  #else
                  tarch::la::Vector<DIMENSIONS,double> _domainOffset;
                  #endif
                  #ifdef UseManualAlignment
                  tarch::la::Vector<DIMENSIONS,double> _domainSize __attribute__((aligned(VectorisationAlignment)));
                  #else
                  tarch::la::Vector<DIMENSIONS,double> _domainSize;
                  #endif
                  int _plotNumber;
                  int _subPlotNumber;
                  double _startMaximumGlobalTimeInterval;
                  double _endMaximumGlobalTimeInterval;
                  double _startMinimumGlobalTimeInterval;
                  double _endMinimumGlobalTimeInterval;
                  double _minimalTimestep;
                  double _totalNumberOfCellUpdates;
                  #ifdef UseManualAlignment
                  tarch::la::Vector<DIMENSIONS,double> _minMeshWidth __attribute__((aligned(VectorisationAlignment)));
                  #else
                  tarch::la::Vector<DIMENSIONS,double> _minMeshWidth;
                  #endif
                  #ifdef UseManualAlignment
                  tarch::la::Vector<DIMENSIONS,double> _maxMeshWidth __attribute__((aligned(VectorisationAlignment)));
                  #else
                  tarch::la::Vector<DIMENSIONS,double> _maxMeshWidth;
                  #endif
                  double _numberOfInnerVertices;
                  double _numberOfBoundaryVertices;
                  double _numberOfOuterVertices;
                  double _numberOfInnerCells;
                  double _numberOfOuterCells;
                  double _numberOfInnerLeafVertices;
                  double _numberOfBoundaryLeafVertices;
                  double _numberOfOuterLeafVertices;
                  double _numberOfInnerLeafCells;
                  double _numberOfOuterLeafCells;
                  int _maxLevel;
                  bool _hasRefined;
                  bool _hasTriggeredRefinementForNextIteration;
                  bool _hasErased;
                  bool _hasTriggeredEraseForNextIteration;
                  bool _hasChangedVertexOrCellState;
                  bool _isTraversalInverted;
                  /**
                   * Generated
                   */
                  PersistentRecords();
                  
                  /**
                   * Generated
                   */
                  PersistentRecords(const int& additionalLevelsForPredefinedRefinement, const bool& isInitializing, const bool& initialRefinmentTriggered, const int& unknownsPerSubcell, const int& auxiliarFieldsPerSubcell, const tarch::la::Vector<DIMENSIONS,double>& initialMinimalMeshWidth, const tarch::la::Vector<DIMENSIONS,int>& defaultSubdivisionFactor, const int& defaultGhostWidthLayer, const double& initialTimestepSize, const bool& useDimensionalSplittingOptimization, const double& globalTimestepEndTime, const bool& allPatchesEvolvedToGlobalTimestep, const tarch::la::Vector<DIMENSIONS,double>& domainOffset, const tarch::la::Vector<DIMENSIONS,double>& domainSize, const int& plotNumber, const int& subPlotNumber, const double& startMaximumGlobalTimeInterval, const double& endMaximumGlobalTimeInterval, const double& startMinimumGlobalTimeInterval, const double& endMinimumGlobalTimeInterval, const double& minimalTimestep, const double& totalNumberOfCellUpdates, const tarch::la::Vector<DIMENSIONS,double>& minMeshWidth, const tarch::la::Vector<DIMENSIONS,double>& maxMeshWidth, const double& numberOfInnerVertices, const double& numberOfBoundaryVertices, const double& numberOfOuterVertices, const double& numberOfInnerCells, const double& numberOfOuterCells, const double& numberOfInnerLeafVertices, const double& numberOfBoundaryLeafVertices, const double& numberOfOuterLeafVertices, const double& numberOfInnerLeafCells, const double& numberOfOuterLeafCells, const int& maxLevel, const bool& hasRefined, const bool& hasTriggeredRefinementForNextIteration, const bool& hasErased, const bool& hasTriggeredEraseForNextIteration, const bool& hasChangedVertexOrCellState, const bool& isTraversalInverted);
                  
                  
                  inline int getAdditionalLevelsForPredefinedRefinement() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _additionalLevelsForPredefinedRefinement;
                  }
                  
                  
                  
                  inline void setAdditionalLevelsForPredefinedRefinement(const int& additionalLevelsForPredefinedRefinement) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _additionalLevelsForPredefinedRefinement = additionalLevelsForPredefinedRefinement;
                  }
                  
                  
                  
                  inline bool getIsInitializing() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _isInitializing;
                  }
                  
                  
                  
                  inline void setIsInitializing(const bool& isInitializing) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _isInitializing = isInitializing;
                  }
                  
                  
                  
                  inline bool getInitialRefinmentTriggered() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _initialRefinmentTriggered;
                  }
                  
                  
                  
                  inline void setInitialRefinmentTriggered(const bool& initialRefinmentTriggered) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _initialRefinmentTriggered = initialRefinmentTriggered;
                  }
                  
                  
                  
                  inline int getUnknownsPerSubcell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _unknownsPerSubcell;
                  }
                  
                  
                  
                  inline void setUnknownsPerSubcell(const int& unknownsPerSubcell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _unknownsPerSubcell = unknownsPerSubcell;
                  }
                  
                  
                  
                  inline int getAuxiliarFieldsPerSubcell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _auxiliarFieldsPerSubcell;
                  }
                  
                  
                  
                  inline void setAuxiliarFieldsPerSubcell(const int& auxiliarFieldsPerSubcell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _auxiliarFieldsPerSubcell = auxiliarFieldsPerSubcell;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline tarch::la::Vector<DIMENSIONS,double> getInitialMinimalMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _initialMinimalMeshWidth;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline void setInitialMinimalMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& initialMinimalMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _initialMinimalMeshWidth = (initialMinimalMeshWidth);
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline tarch::la::Vector<DIMENSIONS,int> getDefaultSubdivisionFactor() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _defaultSubdivisionFactor;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline void setDefaultSubdivisionFactor(const tarch::la::Vector<DIMENSIONS,int>& defaultSubdivisionFactor) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _defaultSubdivisionFactor = (defaultSubdivisionFactor);
                  }
                  
                  
                  
                  inline int getDefaultGhostWidthLayer() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _defaultGhostWidthLayer;
                  }
                  
                  
                  
                  inline void setDefaultGhostWidthLayer(const int& defaultGhostWidthLayer) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _defaultGhostWidthLayer = defaultGhostWidthLayer;
                  }
                  
                  
                  
                  inline double getInitialTimestepSize() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _initialTimestepSize;
                  }
                  
                  
                  
                  inline void setInitialTimestepSize(const double& initialTimestepSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _initialTimestepSize = initialTimestepSize;
                  }
                  
                  
                  
                  inline bool getUseDimensionalSplittingOptimization() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _useDimensionalSplittingOptimization;
                  }
                  
                  
                  
                  inline void setUseDimensionalSplittingOptimization(const bool& useDimensionalSplittingOptimization) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _useDimensionalSplittingOptimization = useDimensionalSplittingOptimization;
                  }
                  
                  
                  
                  inline double getGlobalTimestepEndTime() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _globalTimestepEndTime;
                  }
                  
                  
                  
                  inline void setGlobalTimestepEndTime(const double& globalTimestepEndTime) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _globalTimestepEndTime = globalTimestepEndTime;
                  }
                  
                  
                  
                  inline bool getAllPatchesEvolvedToGlobalTimestep() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _allPatchesEvolvedToGlobalTimestep;
                  }
                  
                  
                  
                  inline void setAllPatchesEvolvedToGlobalTimestep(const bool& allPatchesEvolvedToGlobalTimestep) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _allPatchesEvolvedToGlobalTimestep = allPatchesEvolvedToGlobalTimestep;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline tarch::la::Vector<DIMENSIONS,double> getDomainOffset() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _domainOffset;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline void setDomainOffset(const tarch::la::Vector<DIMENSIONS,double>& domainOffset) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _domainOffset = (domainOffset);
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline tarch::la::Vector<DIMENSIONS,double> getDomainSize() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _domainSize;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline void setDomainSize(const tarch::la::Vector<DIMENSIONS,double>& domainSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _domainSize = (domainSize);
                  }
                  
                  
                  
                  inline int getPlotNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _plotNumber;
                  }
                  
                  
                  
                  inline void setPlotNumber(const int& plotNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _plotNumber = plotNumber;
                  }
                  
                  
                  
                  inline int getSubPlotNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _subPlotNumber;
                  }
                  
                  
                  
                  inline void setSubPlotNumber(const int& subPlotNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _subPlotNumber = subPlotNumber;
                  }
                  
                  
                  
                  inline double getStartMaximumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _startMaximumGlobalTimeInterval;
                  }
                  
                  
                  
                  inline void setStartMaximumGlobalTimeInterval(const double& startMaximumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _startMaximumGlobalTimeInterval = startMaximumGlobalTimeInterval;
                  }
                  
                  
                  
                  inline double getEndMaximumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _endMaximumGlobalTimeInterval;
                  }
                  
                  
                  
                  inline void setEndMaximumGlobalTimeInterval(const double& endMaximumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _endMaximumGlobalTimeInterval = endMaximumGlobalTimeInterval;
                  }
                  
                  
                  
                  inline double getStartMinimumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _startMinimumGlobalTimeInterval;
                  }
                  
                  
                  
                  inline void setStartMinimumGlobalTimeInterval(const double& startMinimumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _startMinimumGlobalTimeInterval = startMinimumGlobalTimeInterval;
                  }
                  
                  
                  
                  inline double getEndMinimumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _endMinimumGlobalTimeInterval;
                  }
                  
                  
                  
                  inline void setEndMinimumGlobalTimeInterval(const double& endMinimumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _endMinimumGlobalTimeInterval = endMinimumGlobalTimeInterval;
                  }
                  
                  
                  
                  inline double getMinimalTimestep() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _minimalTimestep;
                  }
                  
                  
                  
                  inline void setMinimalTimestep(const double& minimalTimestep) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _minimalTimestep = minimalTimestep;
                  }
                  
                  
                  
                  inline double getTotalNumberOfCellUpdates() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _totalNumberOfCellUpdates;
                  }
                  
                  
                  
                  inline void setTotalNumberOfCellUpdates(const double& totalNumberOfCellUpdates) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _totalNumberOfCellUpdates = totalNumberOfCellUpdates;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline tarch::la::Vector<DIMENSIONS,double> getMinMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _minMeshWidth;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline void setMinMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& minMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _minMeshWidth = (minMeshWidth);
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline tarch::la::Vector<DIMENSIONS,double> getMaxMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _maxMeshWidth;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline void setMaxMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& maxMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _maxMeshWidth = (maxMeshWidth);
                  }
                  
                  
                  
                  inline double getNumberOfInnerVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _numberOfInnerVertices;
                  }
                  
                  
                  
                  inline void setNumberOfInnerVertices(const double& numberOfInnerVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _numberOfInnerVertices = numberOfInnerVertices;
                  }
                  
                  
                  
                  inline double getNumberOfBoundaryVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _numberOfBoundaryVertices;
                  }
                  
                  
                  
                  inline void setNumberOfBoundaryVertices(const double& numberOfBoundaryVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _numberOfBoundaryVertices = numberOfBoundaryVertices;
                  }
                  
                  
                  
                  inline double getNumberOfOuterVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _numberOfOuterVertices;
                  }
                  
                  
                  
                  inline void setNumberOfOuterVertices(const double& numberOfOuterVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _numberOfOuterVertices = numberOfOuterVertices;
                  }
                  
                  
                  
                  inline double getNumberOfInnerCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _numberOfInnerCells;
                  }
                  
                  
                  
                  inline void setNumberOfInnerCells(const double& numberOfInnerCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _numberOfInnerCells = numberOfInnerCells;
                  }
                  
                  
                  
                  inline double getNumberOfOuterCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _numberOfOuterCells;
                  }
                  
                  
                  
                  inline void setNumberOfOuterCells(const double& numberOfOuterCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _numberOfOuterCells = numberOfOuterCells;
                  }
                  
                  
                  
                  inline double getNumberOfInnerLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _numberOfInnerLeafVertices;
                  }
                  
                  
                  
                  inline void setNumberOfInnerLeafVertices(const double& numberOfInnerLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _numberOfInnerLeafVertices = numberOfInnerLeafVertices;
                  }
                  
                  
                  
                  inline double getNumberOfBoundaryLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _numberOfBoundaryLeafVertices;
                  }
                  
                  
                  
                  inline void setNumberOfBoundaryLeafVertices(const double& numberOfBoundaryLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _numberOfBoundaryLeafVertices = numberOfBoundaryLeafVertices;
                  }
                  
                  
                  
                  inline double getNumberOfOuterLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _numberOfOuterLeafVertices;
                  }
                  
                  
                  
                  inline void setNumberOfOuterLeafVertices(const double& numberOfOuterLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _numberOfOuterLeafVertices = numberOfOuterLeafVertices;
                  }
                  
                  
                  
                  inline double getNumberOfInnerLeafCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _numberOfInnerLeafCells;
                  }
                  
                  
                  
                  inline void setNumberOfInnerLeafCells(const double& numberOfInnerLeafCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _numberOfInnerLeafCells = numberOfInnerLeafCells;
                  }
                  
                  
                  
                  inline double getNumberOfOuterLeafCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _numberOfOuterLeafCells;
                  }
                  
                  
                  
                  inline void setNumberOfOuterLeafCells(const double& numberOfOuterLeafCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _numberOfOuterLeafCells = numberOfOuterLeafCells;
                  }
                  
                  
                  
                  inline int getMaxLevel() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _maxLevel;
                  }
                  
                  
                  
                  inline void setMaxLevel(const int& maxLevel) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _maxLevel = maxLevel;
                  }
                  
                  
                  
                  inline bool getHasRefined() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _hasRefined;
                  }
                  
                  
                  
                  inline void setHasRefined(const bool& hasRefined) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _hasRefined = hasRefined;
                  }
                  
                  
                  
                  inline bool getHasTriggeredRefinementForNextIteration() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _hasTriggeredRefinementForNextIteration;
                  }
                  
                  
                  
                  inline void setHasTriggeredRefinementForNextIteration(const bool& hasTriggeredRefinementForNextIteration) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _hasTriggeredRefinementForNextIteration = hasTriggeredRefinementForNextIteration;
                  }
                  
                  
                  
                  inline bool getHasErased() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _hasErased;
                  }
                  
                  
                  
                  inline void setHasErased(const bool& hasErased) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _hasErased = hasErased;
                  }
                  
                  
                  
                  inline bool getHasTriggeredEraseForNextIteration() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _hasTriggeredEraseForNextIteration;
                  }
                  
                  
                  
                  inline void setHasTriggeredEraseForNextIteration(const bool& hasTriggeredEraseForNextIteration) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _hasTriggeredEraseForNextIteration = hasTriggeredEraseForNextIteration;
                  }
                  
                  
                  
                  inline bool getHasChangedVertexOrCellState() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _hasChangedVertexOrCellState;
                  }
                  
                  
                  
                  inline void setHasChangedVertexOrCellState(const bool& hasChangedVertexOrCellState) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _hasChangedVertexOrCellState = hasChangedVertexOrCellState;
                  }
                  
                  
                  
                  inline bool getIsTraversalInverted() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _isTraversalInverted;
                  }
                  
                  
                  
                  inline void setIsTraversalInverted(const bool& isTraversalInverted) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _isTraversalInverted = isTraversalInverted;
                  }
                  
                  
                  
               };
               
            private: 
               PersistentRecords _persistentRecords;
               
            public:
               /**
                * Generated
                */
               State();
               
               /**
                * Generated
                */
               State(const PersistentRecords& persistentRecords);
               
               /**
                * Generated
                */
               State(const int& additionalLevelsForPredefinedRefinement, const bool& isInitializing, const bool& initialRefinmentTriggered, const int& unknownsPerSubcell, const int& auxiliarFieldsPerSubcell, const tarch::la::Vector<DIMENSIONS,double>& initialMinimalMeshWidth, const tarch::la::Vector<DIMENSIONS,int>& defaultSubdivisionFactor, const int& defaultGhostWidthLayer, const double& initialTimestepSize, const bool& useDimensionalSplittingOptimization, const double& globalTimestepEndTime, const bool& allPatchesEvolvedToGlobalTimestep, const tarch::la::Vector<DIMENSIONS,double>& domainOffset, const tarch::la::Vector<DIMENSIONS,double>& domainSize, const int& plotNumber, const int& subPlotNumber, const double& startMaximumGlobalTimeInterval, const double& endMaximumGlobalTimeInterval, const double& startMinimumGlobalTimeInterval, const double& endMinimumGlobalTimeInterval, const double& minimalTimestep, const double& totalNumberOfCellUpdates, const tarch::la::Vector<DIMENSIONS,double>& minMeshWidth, const tarch::la::Vector<DIMENSIONS,double>& maxMeshWidth, const double& numberOfInnerVertices, const double& numberOfBoundaryVertices, const double& numberOfOuterVertices, const double& numberOfInnerCells, const double& numberOfOuterCells, const double& numberOfInnerLeafVertices, const double& numberOfBoundaryLeafVertices, const double& numberOfOuterLeafVertices, const double& numberOfInnerLeafCells, const double& numberOfOuterLeafCells, const int& maxLevel, const bool& hasRefined, const bool& hasTriggeredRefinementForNextIteration, const bool& hasErased, const bool& hasTriggeredEraseForNextIteration, const bool& hasChangedVertexOrCellState, const bool& isTraversalInverted);
               
               /**
                * Generated
                */
               virtual ~State();
               
               
               inline int getAdditionalLevelsForPredefinedRefinement() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._additionalLevelsForPredefinedRefinement;
               }
               
               
               
               inline void setAdditionalLevelsForPredefinedRefinement(const int& additionalLevelsForPredefinedRefinement) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._additionalLevelsForPredefinedRefinement = additionalLevelsForPredefinedRefinement;
               }
               
               
               
               inline bool getIsInitializing() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._isInitializing;
               }
               
               
               
               inline void setIsInitializing(const bool& isInitializing) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._isInitializing = isInitializing;
               }
               
               
               
               inline bool getInitialRefinmentTriggered() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._initialRefinmentTriggered;
               }
               
               
               
               inline void setInitialRefinmentTriggered(const bool& initialRefinmentTriggered) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._initialRefinmentTriggered = initialRefinmentTriggered;
               }
               
               
               
               inline int getUnknownsPerSubcell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._unknownsPerSubcell;
               }
               
               
               
               inline void setUnknownsPerSubcell(const int& unknownsPerSubcell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._unknownsPerSubcell = unknownsPerSubcell;
               }
               
               
               
               inline int getAuxiliarFieldsPerSubcell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._auxiliarFieldsPerSubcell;
               }
               
               
               
               inline void setAuxiliarFieldsPerSubcell(const int& auxiliarFieldsPerSubcell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._auxiliarFieldsPerSubcell = auxiliarFieldsPerSubcell;
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline tarch::la::Vector<DIMENSIONS,double> getInitialMinimalMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._initialMinimalMeshWidth;
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline void setInitialMinimalMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& initialMinimalMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._initialMinimalMeshWidth = (initialMinimalMeshWidth);
               }
               
               
               
               inline double getInitialMinimalMeshWidth(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  assertion(elementIndex>=0);
                  assertion(elementIndex<DIMENSIONS);
                  return _persistentRecords._initialMinimalMeshWidth[elementIndex];
                  
               }
               
               
               
               inline void setInitialMinimalMeshWidth(int elementIndex, const double& initialMinimalMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  assertion(elementIndex>=0);
                  assertion(elementIndex<DIMENSIONS);
                  _persistentRecords._initialMinimalMeshWidth[elementIndex]= initialMinimalMeshWidth;
                  
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline tarch::la::Vector<DIMENSIONS,int> getDefaultSubdivisionFactor() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._defaultSubdivisionFactor;
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline void setDefaultSubdivisionFactor(const tarch::la::Vector<DIMENSIONS,int>& defaultSubdivisionFactor) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._defaultSubdivisionFactor = (defaultSubdivisionFactor);
               }
               
               
               
               inline int getDefaultSubdivisionFactor(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  assertion(elementIndex>=0);
                  assertion(elementIndex<DIMENSIONS);
                  return _persistentRecords._defaultSubdivisionFactor[elementIndex];
                  
               }
               
               
               
               inline void setDefaultSubdivisionFactor(int elementIndex, const int& defaultSubdivisionFactor) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  assertion(elementIndex>=0);
                  assertion(elementIndex<DIMENSIONS);
                  _persistentRecords._defaultSubdivisionFactor[elementIndex]= defaultSubdivisionFactor;
                  
               }
               
               
               
               inline int getDefaultGhostWidthLayer() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._defaultGhostWidthLayer;
               }
               
               
               
               inline void setDefaultGhostWidthLayer(const int& defaultGhostWidthLayer) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._defaultGhostWidthLayer = defaultGhostWidthLayer;
               }
               
               
               
               inline double getInitialTimestepSize() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._initialTimestepSize;
               }
               
               
               
               inline void setInitialTimestepSize(const double& initialTimestepSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._initialTimestepSize = initialTimestepSize;
               }
               
               
               
               inline bool getUseDimensionalSplittingOptimization() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._useDimensionalSplittingOptimization;
               }
               
               
               
               inline void setUseDimensionalSplittingOptimization(const bool& useDimensionalSplittingOptimization) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._useDimensionalSplittingOptimization = useDimensionalSplittingOptimization;
               }
               
               
               
               inline double getGlobalTimestepEndTime() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._globalTimestepEndTime;
               }
               
               
               
               inline void setGlobalTimestepEndTime(const double& globalTimestepEndTime) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._globalTimestepEndTime = globalTimestepEndTime;
               }
               
               
               
               inline bool getAllPatchesEvolvedToGlobalTimestep() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._allPatchesEvolvedToGlobalTimestep;
               }
               
               
               
               inline void setAllPatchesEvolvedToGlobalTimestep(const bool& allPatchesEvolvedToGlobalTimestep) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._allPatchesEvolvedToGlobalTimestep = allPatchesEvolvedToGlobalTimestep;
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline tarch::la::Vector<DIMENSIONS,double> getDomainOffset() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._domainOffset;
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline void setDomainOffset(const tarch::la::Vector<DIMENSIONS,double>& domainOffset) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._domainOffset = (domainOffset);
               }
               
               
               
               inline double getDomainOffset(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  assertion(elementIndex>=0);
                  assertion(elementIndex<DIMENSIONS);
                  return _persistentRecords._domainOffset[elementIndex];
                  
               }
               
               
               
               inline void setDomainOffset(int elementIndex, const double& domainOffset) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  assertion(elementIndex>=0);
                  assertion(elementIndex<DIMENSIONS);
                  _persistentRecords._domainOffset[elementIndex]= domainOffset;
                  
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline tarch::la::Vector<DIMENSIONS,double> getDomainSize() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._domainSize;
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline void setDomainSize(const tarch::la::Vector<DIMENSIONS,double>& domainSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._domainSize = (domainSize);
               }
               
               
               
               inline double getDomainSize(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  assertion(elementIndex>=0);
                  assertion(elementIndex<DIMENSIONS);
                  return _persistentRecords._domainSize[elementIndex];
                  
               }
               
               
               
               inline void setDomainSize(int elementIndex, const double& domainSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  assertion(elementIndex>=0);
                  assertion(elementIndex<DIMENSIONS);
                  _persistentRecords._domainSize[elementIndex]= domainSize;
                  
               }
               
               
               
               inline int getPlotNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._plotNumber;
               }
               
               
               
               inline void setPlotNumber(const int& plotNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._plotNumber = plotNumber;
               }
               
               
               
               inline int getSubPlotNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._subPlotNumber;
               }
               
               
               
               inline void setSubPlotNumber(const int& subPlotNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._subPlotNumber = subPlotNumber;
               }
               
               
               
               inline double getStartMaximumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._startMaximumGlobalTimeInterval;
               }
               
               
               
               inline void setStartMaximumGlobalTimeInterval(const double& startMaximumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._startMaximumGlobalTimeInterval = startMaximumGlobalTimeInterval;
               }
               
               
               
               inline double getEndMaximumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._endMaximumGlobalTimeInterval;
               }
               
               
               
               inline void setEndMaximumGlobalTimeInterval(const double& endMaximumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._endMaximumGlobalTimeInterval = endMaximumGlobalTimeInterval;
               }
               
               
               
               inline double getStartMinimumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._startMinimumGlobalTimeInterval;
               }
               
               
               
               inline void setStartMinimumGlobalTimeInterval(const double& startMinimumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._startMinimumGlobalTimeInterval = startMinimumGlobalTimeInterval;
               }
               
               
               
               inline double getEndMinimumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._endMinimumGlobalTimeInterval;
               }
               
               
               
               inline void setEndMinimumGlobalTimeInterval(const double& endMinimumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._endMinimumGlobalTimeInterval = endMinimumGlobalTimeInterval;
               }
               
               
               
               inline double getMinimalTimestep() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._minimalTimestep;
               }
               
               
               
               inline void setMinimalTimestep(const double& minimalTimestep) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._minimalTimestep = minimalTimestep;
               }
               
               
               
               inline double getTotalNumberOfCellUpdates() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._totalNumberOfCellUpdates;
               }
               
               
               
               inline void setTotalNumberOfCellUpdates(const double& totalNumberOfCellUpdates) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._totalNumberOfCellUpdates = totalNumberOfCellUpdates;
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline tarch::la::Vector<DIMENSIONS,double> getMinMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._minMeshWidth;
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline void setMinMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& minMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._minMeshWidth = (minMeshWidth);
               }
               
               
               
               inline double getMinMeshWidth(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  assertion(elementIndex>=0);
                  assertion(elementIndex<DIMENSIONS);
                  return _persistentRecords._minMeshWidth[elementIndex];
                  
               }
               
               
               
               inline void setMinMeshWidth(int elementIndex, const double& minMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  assertion(elementIndex>=0);
                  assertion(elementIndex<DIMENSIONS);
                  _persistentRecords._minMeshWidth[elementIndex]= minMeshWidth;
                  
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline tarch::la::Vector<DIMENSIONS,double> getMaxMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._maxMeshWidth;
               }
               
               
               
               /**
                * Generated and optimized
                * 
                * If you realise a for loop using exclusively arrays (vectors) and compile 
                * with -DUseManualAlignment you may add 
                * \code
                #pragma vector aligned
                #pragma simd
                \endcode to this for loop to enforce your compiler to use SSE/AVX.
                * 
                * The alignment is tied to the unpacked records, i.e. for packed class
                * variants the machine's natural alignment is switched off to recude the  
                * memory footprint. Do not use any SSE/AVX operations or 
                * vectorisation on the result for the packed variants, as the data is misaligned. 
                * If you rely on vectorisation, convert the underlying record 
                * into the unpacked version first. 
                * 
                * @see convert()
                */
               inline void setMaxMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& maxMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._maxMeshWidth = (maxMeshWidth);
               }
               
               
               
               inline double getMaxMeshWidth(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  assertion(elementIndex>=0);
                  assertion(elementIndex<DIMENSIONS);
                  return _persistentRecords._maxMeshWidth[elementIndex];
                  
               }
               
               
               
               inline void setMaxMeshWidth(int elementIndex, const double& maxMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  assertion(elementIndex>=0);
                  assertion(elementIndex<DIMENSIONS);
                  _persistentRecords._maxMeshWidth[elementIndex]= maxMeshWidth;
                  
               }
               
               
               
               inline double getNumberOfInnerVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._numberOfInnerVertices;
               }
               
               
               
               inline void setNumberOfInnerVertices(const double& numberOfInnerVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._numberOfInnerVertices = numberOfInnerVertices;
               }
               
               
               
               inline double getNumberOfBoundaryVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._numberOfBoundaryVertices;
               }
               
               
               
               inline void setNumberOfBoundaryVertices(const double& numberOfBoundaryVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._numberOfBoundaryVertices = numberOfBoundaryVertices;
               }
               
               
               
               inline double getNumberOfOuterVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._numberOfOuterVertices;
               }
               
               
               
               inline void setNumberOfOuterVertices(const double& numberOfOuterVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._numberOfOuterVertices = numberOfOuterVertices;
               }
               
               
               
               inline double getNumberOfInnerCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._numberOfInnerCells;
               }
               
               
               
               inline void setNumberOfInnerCells(const double& numberOfInnerCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._numberOfInnerCells = numberOfInnerCells;
               }
               
               
               
               inline double getNumberOfOuterCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._numberOfOuterCells;
               }
               
               
               
               inline void setNumberOfOuterCells(const double& numberOfOuterCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._numberOfOuterCells = numberOfOuterCells;
               }
               
               
               
               inline double getNumberOfInnerLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._numberOfInnerLeafVertices;
               }
               
               
               
               inline void setNumberOfInnerLeafVertices(const double& numberOfInnerLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._numberOfInnerLeafVertices = numberOfInnerLeafVertices;
               }
               
               
               
               inline double getNumberOfBoundaryLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._numberOfBoundaryLeafVertices;
               }
               
               
               
               inline void setNumberOfBoundaryLeafVertices(const double& numberOfBoundaryLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._numberOfBoundaryLeafVertices = numberOfBoundaryLeafVertices;
               }
               
               
               
               inline double getNumberOfOuterLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._numberOfOuterLeafVertices;
               }
               
               
               
               inline void setNumberOfOuterLeafVertices(const double& numberOfOuterLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._numberOfOuterLeafVertices = numberOfOuterLeafVertices;
               }
               
               
               
               inline double getNumberOfInnerLeafCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._numberOfInnerLeafCells;
               }
               
               
               
               inline void setNumberOfInnerLeafCells(const double& numberOfInnerLeafCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._numberOfInnerLeafCells = numberOfInnerLeafCells;
               }
               
               
               
               inline double getNumberOfOuterLeafCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._numberOfOuterLeafCells;
               }
               
               
               
               inline void setNumberOfOuterLeafCells(const double& numberOfOuterLeafCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._numberOfOuterLeafCells = numberOfOuterLeafCells;
               }
               
               
               
               inline int getMaxLevel() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._maxLevel;
               }
               
               
               
               inline void setMaxLevel(const int& maxLevel) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._maxLevel = maxLevel;
               }
               
               
               
               inline bool getHasRefined() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._hasRefined;
               }
               
               
               
               inline void setHasRefined(const bool& hasRefined) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._hasRefined = hasRefined;
               }
               
               
               
               inline bool getHasTriggeredRefinementForNextIteration() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._hasTriggeredRefinementForNextIteration;
               }
               
               
               
               inline void setHasTriggeredRefinementForNextIteration(const bool& hasTriggeredRefinementForNextIteration) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._hasTriggeredRefinementForNextIteration = hasTriggeredRefinementForNextIteration;
               }
               
               
               
               inline bool getHasErased() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._hasErased;
               }
               
               
               
               inline void setHasErased(const bool& hasErased) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._hasErased = hasErased;
               }
               
               
               
               inline bool getHasTriggeredEraseForNextIteration() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._hasTriggeredEraseForNextIteration;
               }
               
               
               
               inline void setHasTriggeredEraseForNextIteration(const bool& hasTriggeredEraseForNextIteration) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._hasTriggeredEraseForNextIteration = hasTriggeredEraseForNextIteration;
               }
               
               
               
               inline bool getHasChangedVertexOrCellState() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._hasChangedVertexOrCellState;
               }
               
               
               
               inline void setHasChangedVertexOrCellState(const bool& hasChangedVertexOrCellState) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._hasChangedVertexOrCellState = hasChangedVertexOrCellState;
               }
               
               
               
               inline bool getIsTraversalInverted() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  return _persistentRecords._isTraversalInverted;
               }
               
               
               
               inline void setIsTraversalInverted(const bool& isTraversalInverted) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                  _persistentRecords._isTraversalInverted = isTraversalInverted;
               }
               
               
               /**
                * Generated
                */
               std::string toString() const;
               
               /**
                * Generated
                */
               void toString(std::ostream& out) const;
               
               
               PersistentRecords getPersistentRecords() const;
               /**
                * Generated
                */
               StatePacked convert() const;
               
               
            #ifdef Parallel
               protected:
                  static tarch::logging::Log _log;
                  
                  int _senderDestinationRank;
                  
               public:
                  
                  /**
                   * Global that represents the mpi datatype.
                   * There are two variants: Datatype identifies only those attributes marked with
                   * parallelise. FullDatatype instead identifies the whole record with all fields.
                   */
                  static MPI_Datatype Datatype;
                  static MPI_Datatype FullDatatype;
                  
                  /**
                   * Initializes the data type for the mpi operations. Has to be called
                   * before the very first send or receive operation is called.
                   */
                  static void initDatatype();
                  
                  static void shutdownDatatype();
                  
                  void send(int destination, int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
                  
                  void receive(int source, int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
                  
                  static bool isMessageInQueue(int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
                  
                  int getSenderRank() const;
                  
            #endif
               
            };
            
            #ifndef DaStGenPackedPadding
              #define DaStGenPackedPadding 1      // 32 bit version
              // #define DaStGenPackedPadding 2   // 64 bit version
            #endif
            
            
            #ifdef PackedRecords
               #pragma pack (push, DaStGenPackedPadding)
            #endif
            
            /**
             * @author This class is generated by DaStGen
             * 		   DataStructureGenerator (DaStGen)
             * 		   2007-2009 Wolfgang Eckhardt
             * 		   2012      Tobias Weinzierl
             *
             * 		   build date: 12-04-2013 09:18
             *
             * @date   18/07/2013 13:56
             */
            class peanoclaw::records::StatePacked { 
               
               public:
                  
                  struct PersistentRecords {
                     int _additionalLevelsForPredefinedRefinement;
                     bool _isInitializing;
                     bool _initialRefinmentTriggered;
                     int _unknownsPerSubcell;
                     int _auxiliarFieldsPerSubcell;
                     tarch::la::Vector<DIMENSIONS,double> _initialMinimalMeshWidth;
                     tarch::la::Vector<DIMENSIONS,int> _defaultSubdivisionFactor;
                     int _defaultGhostWidthLayer;
                     double _initialTimestepSize;
                     bool _useDimensionalSplittingOptimization;
                     double _globalTimestepEndTime;
                     tarch::la::Vector<DIMENSIONS,double> _domainOffset;
                     tarch::la::Vector<DIMENSIONS,double> _domainSize;
                     int _plotNumber;
                     int _subPlotNumber;
                     double _startMaximumGlobalTimeInterval;
                     double _endMaximumGlobalTimeInterval;
                     double _startMinimumGlobalTimeInterval;
                     double _endMinimumGlobalTimeInterval;
                     double _minimalTimestep;
                     double _totalNumberOfCellUpdates;
                     tarch::la::Vector<DIMENSIONS,double> _minMeshWidth;
                     tarch::la::Vector<DIMENSIONS,double> _maxMeshWidth;
                     double _numberOfInnerVertices;
                     double _numberOfBoundaryVertices;
                     double _numberOfOuterVertices;
                     double _numberOfInnerCells;
                     double _numberOfOuterCells;
                     double _numberOfInnerLeafVertices;
                     double _numberOfBoundaryLeafVertices;
                     double _numberOfOuterLeafVertices;
                     double _numberOfInnerLeafCells;
                     double _numberOfOuterLeafCells;
                     int _maxLevel;
                     bool _isTraversalInverted;
                     
                     /** mapping of records:
                     || Member 	|| startbit 	|| length
                      |  allPatchesEvolvedToGlobalTimestep	| startbit 0	| #bits 1
                      |  hasRefined	| startbit 1	| #bits 1
                      |  hasTriggeredRefinementForNextIteration	| startbit 2	| #bits 1
                      |  hasErased	| startbit 3	| #bits 1
                      |  hasTriggeredEraseForNextIteration	| startbit 4	| #bits 1
                      |  hasChangedVertexOrCellState	| startbit 5	| #bits 1
                      */
                     short int _packedRecords0;
                     
                     /**
                      * Generated
                      */
                     PersistentRecords();
                     
                     /**
                      * Generated
                      */
                     PersistentRecords(const int& additionalLevelsForPredefinedRefinement, const bool& isInitializing, const bool& initialRefinmentTriggered, const int& unknownsPerSubcell, const int& auxiliarFieldsPerSubcell, const tarch::la::Vector<DIMENSIONS,double>& initialMinimalMeshWidth, const tarch::la::Vector<DIMENSIONS,int>& defaultSubdivisionFactor, const int& defaultGhostWidthLayer, const double& initialTimestepSize, const bool& useDimensionalSplittingOptimization, const double& globalTimestepEndTime, const bool& allPatchesEvolvedToGlobalTimestep, const tarch::la::Vector<DIMENSIONS,double>& domainOffset, const tarch::la::Vector<DIMENSIONS,double>& domainSize, const int& plotNumber, const int& subPlotNumber, const double& startMaximumGlobalTimeInterval, const double& endMaximumGlobalTimeInterval, const double& startMinimumGlobalTimeInterval, const double& endMinimumGlobalTimeInterval, const double& minimalTimestep, const double& totalNumberOfCellUpdates, const tarch::la::Vector<DIMENSIONS,double>& minMeshWidth, const tarch::la::Vector<DIMENSIONS,double>& maxMeshWidth, const double& numberOfInnerVertices, const double& numberOfBoundaryVertices, const double& numberOfOuterVertices, const double& numberOfInnerCells, const double& numberOfOuterCells, const double& numberOfInnerLeafVertices, const double& numberOfBoundaryLeafVertices, const double& numberOfOuterLeafVertices, const double& numberOfInnerLeafCells, const double& numberOfOuterLeafCells, const int& maxLevel, const bool& hasRefined, const bool& hasTriggeredRefinementForNextIteration, const bool& hasErased, const bool& hasTriggeredEraseForNextIteration, const bool& hasChangedVertexOrCellState, const bool& isTraversalInverted);
                     
                     
                     inline int getAdditionalLevelsForPredefinedRefinement() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _additionalLevelsForPredefinedRefinement;
                     }
                     
                     
                     
                     inline void setAdditionalLevelsForPredefinedRefinement(const int& additionalLevelsForPredefinedRefinement) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _additionalLevelsForPredefinedRefinement = additionalLevelsForPredefinedRefinement;
                     }
                     
                     
                     
                     inline bool getIsInitializing() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _isInitializing;
                     }
                     
                     
                     
                     inline void setIsInitializing(const bool& isInitializing) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _isInitializing = isInitializing;
                     }
                     
                     
                     
                     inline bool getInitialRefinmentTriggered() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _initialRefinmentTriggered;
                     }
                     
                     
                     
                     inline void setInitialRefinmentTriggered(const bool& initialRefinmentTriggered) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _initialRefinmentTriggered = initialRefinmentTriggered;
                     }
                     
                     
                     
                     inline int getUnknownsPerSubcell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _unknownsPerSubcell;
                     }
                     
                     
                     
                     inline void setUnknownsPerSubcell(const int& unknownsPerSubcell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _unknownsPerSubcell = unknownsPerSubcell;
                     }
                     
                     
                     
                     inline int getAuxiliarFieldsPerSubcell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _auxiliarFieldsPerSubcell;
                     }
                     
                     
                     
                     inline void setAuxiliarFieldsPerSubcell(const int& auxiliarFieldsPerSubcell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _auxiliarFieldsPerSubcell = auxiliarFieldsPerSubcell;
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline tarch::la::Vector<DIMENSIONS,double> getInitialMinimalMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _initialMinimalMeshWidth;
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline void setInitialMinimalMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& initialMinimalMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _initialMinimalMeshWidth = (initialMinimalMeshWidth);
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline tarch::la::Vector<DIMENSIONS,int> getDefaultSubdivisionFactor() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _defaultSubdivisionFactor;
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline void setDefaultSubdivisionFactor(const tarch::la::Vector<DIMENSIONS,int>& defaultSubdivisionFactor) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _defaultSubdivisionFactor = (defaultSubdivisionFactor);
                     }
                     
                     
                     
                     inline int getDefaultGhostWidthLayer() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _defaultGhostWidthLayer;
                     }
                     
                     
                     
                     inline void setDefaultGhostWidthLayer(const int& defaultGhostWidthLayer) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _defaultGhostWidthLayer = defaultGhostWidthLayer;
                     }
                     
                     
                     
                     inline double getInitialTimestepSize() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _initialTimestepSize;
                     }
                     
                     
                     
                     inline void setInitialTimestepSize(const double& initialTimestepSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _initialTimestepSize = initialTimestepSize;
                     }
                     
                     
                     
                     inline bool getUseDimensionalSplittingOptimization() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _useDimensionalSplittingOptimization;
                     }
                     
                     
                     
                     inline void setUseDimensionalSplittingOptimization(const bool& useDimensionalSplittingOptimization) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _useDimensionalSplittingOptimization = useDimensionalSplittingOptimization;
                     }
                     
                     
                     
                     inline double getGlobalTimestepEndTime() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _globalTimestepEndTime;
                     }
                     
                     
                     
                     inline void setGlobalTimestepEndTime(const double& globalTimestepEndTime) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _globalTimestepEndTime = globalTimestepEndTime;
                     }
                     
                     
                     
                     inline bool getAllPatchesEvolvedToGlobalTimestep() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        short int mask = 1 << (0);
   short int tmp = static_cast<short int>(_packedRecords0 & mask);
   return (tmp != 0);
                     }
                     
                     
                     
                     inline void setAllPatchesEvolvedToGlobalTimestep(const bool& allPatchesEvolvedToGlobalTimestep) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        short int mask = 1 << (0);
   _packedRecords0 = static_cast<short int>( allPatchesEvolvedToGlobalTimestep ? (_packedRecords0 | mask) : (_packedRecords0 & ~mask));
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline tarch::la::Vector<DIMENSIONS,double> getDomainOffset() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _domainOffset;
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline void setDomainOffset(const tarch::la::Vector<DIMENSIONS,double>& domainOffset) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _domainOffset = (domainOffset);
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline tarch::la::Vector<DIMENSIONS,double> getDomainSize() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _domainSize;
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline void setDomainSize(const tarch::la::Vector<DIMENSIONS,double>& domainSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _domainSize = (domainSize);
                     }
                     
                     
                     
                     inline int getPlotNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _plotNumber;
                     }
                     
                     
                     
                     inline void setPlotNumber(const int& plotNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _plotNumber = plotNumber;
                     }
                     
                     
                     
                     inline int getSubPlotNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _subPlotNumber;
                     }
                     
                     
                     
                     inline void setSubPlotNumber(const int& subPlotNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _subPlotNumber = subPlotNumber;
                     }
                     
                     
                     
                     inline double getStartMaximumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _startMaximumGlobalTimeInterval;
                     }
                     
                     
                     
                     inline void setStartMaximumGlobalTimeInterval(const double& startMaximumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _startMaximumGlobalTimeInterval = startMaximumGlobalTimeInterval;
                     }
                     
                     
                     
                     inline double getEndMaximumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _endMaximumGlobalTimeInterval;
                     }
                     
                     
                     
                     inline void setEndMaximumGlobalTimeInterval(const double& endMaximumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _endMaximumGlobalTimeInterval = endMaximumGlobalTimeInterval;
                     }
                     
                     
                     
                     inline double getStartMinimumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _startMinimumGlobalTimeInterval;
                     }
                     
                     
                     
                     inline void setStartMinimumGlobalTimeInterval(const double& startMinimumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _startMinimumGlobalTimeInterval = startMinimumGlobalTimeInterval;
                     }
                     
                     
                     
                     inline double getEndMinimumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _endMinimumGlobalTimeInterval;
                     }
                     
                     
                     
                     inline void setEndMinimumGlobalTimeInterval(const double& endMinimumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _endMinimumGlobalTimeInterval = endMinimumGlobalTimeInterval;
                     }
                     
                     
                     
                     inline double getMinimalTimestep() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _minimalTimestep;
                     }
                     
                     
                     
                     inline void setMinimalTimestep(const double& minimalTimestep) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _minimalTimestep = minimalTimestep;
                     }
                     
                     
                     
                     inline double getTotalNumberOfCellUpdates() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _totalNumberOfCellUpdates;
                     }
                     
                     
                     
                     inline void setTotalNumberOfCellUpdates(const double& totalNumberOfCellUpdates) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _totalNumberOfCellUpdates = totalNumberOfCellUpdates;
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline tarch::la::Vector<DIMENSIONS,double> getMinMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _minMeshWidth;
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline void setMinMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& minMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _minMeshWidth = (minMeshWidth);
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline tarch::la::Vector<DIMENSIONS,double> getMaxMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _maxMeshWidth;
                     }
                     
                     
                     
                     /**
                      * Generated and optimized
                      * 
                      * If you realise a for loop using exclusively arrays (vectors) and compile 
                      * with -DUseManualAlignment you may add 
                      * \code
                      #pragma vector aligned
                      #pragma simd
                      \endcode to this for loop to enforce your compiler to use SSE/AVX.
                      * 
                      * The alignment is tied to the unpacked records, i.e. for packed class
                      * variants the machine's natural alignment is switched off to recude the  
                      * memory footprint. Do not use any SSE/AVX operations or 
                      * vectorisation on the result for the packed variants, as the data is misaligned. 
                      * If you rely on vectorisation, convert the underlying record 
                      * into the unpacked version first. 
                      * 
                      * @see convert()
                      */
                     inline void setMaxMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& maxMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _maxMeshWidth = (maxMeshWidth);
                     }
                     
                     
                     
                     inline double getNumberOfInnerVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _numberOfInnerVertices;
                     }
                     
                     
                     
                     inline void setNumberOfInnerVertices(const double& numberOfInnerVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _numberOfInnerVertices = numberOfInnerVertices;
                     }
                     
                     
                     
                     inline double getNumberOfBoundaryVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _numberOfBoundaryVertices;
                     }
                     
                     
                     
                     inline void setNumberOfBoundaryVertices(const double& numberOfBoundaryVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _numberOfBoundaryVertices = numberOfBoundaryVertices;
                     }
                     
                     
                     
                     inline double getNumberOfOuterVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _numberOfOuterVertices;
                     }
                     
                     
                     
                     inline void setNumberOfOuterVertices(const double& numberOfOuterVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _numberOfOuterVertices = numberOfOuterVertices;
                     }
                     
                     
                     
                     inline double getNumberOfInnerCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _numberOfInnerCells;
                     }
                     
                     
                     
                     inline void setNumberOfInnerCells(const double& numberOfInnerCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _numberOfInnerCells = numberOfInnerCells;
                     }
                     
                     
                     
                     inline double getNumberOfOuterCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _numberOfOuterCells;
                     }
                     
                     
                     
                     inline void setNumberOfOuterCells(const double& numberOfOuterCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _numberOfOuterCells = numberOfOuterCells;
                     }
                     
                     
                     
                     inline double getNumberOfInnerLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _numberOfInnerLeafVertices;
                     }
                     
                     
                     
                     inline void setNumberOfInnerLeafVertices(const double& numberOfInnerLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _numberOfInnerLeafVertices = numberOfInnerLeafVertices;
                     }
                     
                     
                     
                     inline double getNumberOfBoundaryLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _numberOfBoundaryLeafVertices;
                     }
                     
                     
                     
                     inline void setNumberOfBoundaryLeafVertices(const double& numberOfBoundaryLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _numberOfBoundaryLeafVertices = numberOfBoundaryLeafVertices;
                     }
                     
                     
                     
                     inline double getNumberOfOuterLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _numberOfOuterLeafVertices;
                     }
                     
                     
                     
                     inline void setNumberOfOuterLeafVertices(const double& numberOfOuterLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _numberOfOuterLeafVertices = numberOfOuterLeafVertices;
                     }
                     
                     
                     
                     inline double getNumberOfInnerLeafCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _numberOfInnerLeafCells;
                     }
                     
                     
                     
                     inline void setNumberOfInnerLeafCells(const double& numberOfInnerLeafCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _numberOfInnerLeafCells = numberOfInnerLeafCells;
                     }
                     
                     
                     
                     inline double getNumberOfOuterLeafCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _numberOfOuterLeafCells;
                     }
                     
                     
                     
                     inline void setNumberOfOuterLeafCells(const double& numberOfOuterLeafCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _numberOfOuterLeafCells = numberOfOuterLeafCells;
                     }
                     
                     
                     
                     inline int getMaxLevel() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _maxLevel;
                     }
                     
                     
                     
                     inline void setMaxLevel(const int& maxLevel) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _maxLevel = maxLevel;
                     }
                     
                     
                     
                     inline bool getHasRefined() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        short int mask = 1 << (1);
   short int tmp = static_cast<short int>(_packedRecords0 & mask);
   return (tmp != 0);
                     }
                     
                     
                     
                     inline void setHasRefined(const bool& hasRefined) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        short int mask = 1 << (1);
   _packedRecords0 = static_cast<short int>( hasRefined ? (_packedRecords0 | mask) : (_packedRecords0 & ~mask));
                     }
                     
                     
                     
                     inline bool getHasTriggeredRefinementForNextIteration() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        short int mask = 1 << (2);
   short int tmp = static_cast<short int>(_packedRecords0 & mask);
   return (tmp != 0);
                     }
                     
                     
                     
                     inline void setHasTriggeredRefinementForNextIteration(const bool& hasTriggeredRefinementForNextIteration) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        short int mask = 1 << (2);
   _packedRecords0 = static_cast<short int>( hasTriggeredRefinementForNextIteration ? (_packedRecords0 | mask) : (_packedRecords0 & ~mask));
                     }
                     
                     
                     
                     inline bool getHasErased() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        short int mask = 1 << (3);
   short int tmp = static_cast<short int>(_packedRecords0 & mask);
   return (tmp != 0);
                     }
                     
                     
                     
                     inline void setHasErased(const bool& hasErased) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        short int mask = 1 << (3);
   _packedRecords0 = static_cast<short int>( hasErased ? (_packedRecords0 | mask) : (_packedRecords0 & ~mask));
                     }
                     
                     
                     
                     inline bool getHasTriggeredEraseForNextIteration() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        short int mask = 1 << (4);
   short int tmp = static_cast<short int>(_packedRecords0 & mask);
   return (tmp != 0);
                     }
                     
                     
                     
                     inline void setHasTriggeredEraseForNextIteration(const bool& hasTriggeredEraseForNextIteration) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        short int mask = 1 << (4);
   _packedRecords0 = static_cast<short int>( hasTriggeredEraseForNextIteration ? (_packedRecords0 | mask) : (_packedRecords0 & ~mask));
                     }
                     
                     
                     
                     inline bool getHasChangedVertexOrCellState() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        short int mask = 1 << (5);
   short int tmp = static_cast<short int>(_packedRecords0 & mask);
   return (tmp != 0);
                     }
                     
                     
                     
                     inline void setHasChangedVertexOrCellState(const bool& hasChangedVertexOrCellState) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        short int mask = 1 << (5);
   _packedRecords0 = static_cast<short int>( hasChangedVertexOrCellState ? (_packedRecords0 | mask) : (_packedRecords0 & ~mask));
                     }
                     
                     
                     
                     inline bool getIsTraversalInverted() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        return _isTraversalInverted;
                     }
                     
                     
                     
                     inline void setIsTraversalInverted(const bool& isTraversalInverted) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                        _isTraversalInverted = isTraversalInverted;
                     }
                     
                     
                     
                  };
                  
               private: 
                  PersistentRecords _persistentRecords;
                  
               public:
                  /**
                   * Generated
                   */
                  StatePacked();
                  
                  /**
                   * Generated
                   */
                  StatePacked(const PersistentRecords& persistentRecords);
                  
                  /**
                   * Generated
                   */
                  StatePacked(const int& additionalLevelsForPredefinedRefinement, const bool& isInitializing, const bool& initialRefinmentTriggered, const int& unknownsPerSubcell, const int& auxiliarFieldsPerSubcell, const tarch::la::Vector<DIMENSIONS,double>& initialMinimalMeshWidth, const tarch::la::Vector<DIMENSIONS,int>& defaultSubdivisionFactor, const int& defaultGhostWidthLayer, const double& initialTimestepSize, const bool& useDimensionalSplittingOptimization, const double& globalTimestepEndTime, const bool& allPatchesEvolvedToGlobalTimestep, const tarch::la::Vector<DIMENSIONS,double>& domainOffset, const tarch::la::Vector<DIMENSIONS,double>& domainSize, const int& plotNumber, const int& subPlotNumber, const double& startMaximumGlobalTimeInterval, const double& endMaximumGlobalTimeInterval, const double& startMinimumGlobalTimeInterval, const double& endMinimumGlobalTimeInterval, const double& minimalTimestep, const double& totalNumberOfCellUpdates, const tarch::la::Vector<DIMENSIONS,double>& minMeshWidth, const tarch::la::Vector<DIMENSIONS,double>& maxMeshWidth, const double& numberOfInnerVertices, const double& numberOfBoundaryVertices, const double& numberOfOuterVertices, const double& numberOfInnerCells, const double& numberOfOuterCells, const double& numberOfInnerLeafVertices, const double& numberOfBoundaryLeafVertices, const double& numberOfOuterLeafVertices, const double& numberOfInnerLeafCells, const double& numberOfOuterLeafCells, const int& maxLevel, const bool& hasRefined, const bool& hasTriggeredRefinementForNextIteration, const bool& hasErased, const bool& hasTriggeredEraseForNextIteration, const bool& hasChangedVertexOrCellState, const bool& isTraversalInverted);
                  
                  /**
                   * Generated
                   */
                  virtual ~StatePacked();
                  
                  
                  inline int getAdditionalLevelsForPredefinedRefinement() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._additionalLevelsForPredefinedRefinement;
                  }
                  
                  
                  
                  inline void setAdditionalLevelsForPredefinedRefinement(const int& additionalLevelsForPredefinedRefinement) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._additionalLevelsForPredefinedRefinement = additionalLevelsForPredefinedRefinement;
                  }
                  
                  
                  
                  inline bool getIsInitializing() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._isInitializing;
                  }
                  
                  
                  
                  inline void setIsInitializing(const bool& isInitializing) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._isInitializing = isInitializing;
                  }
                  
                  
                  
                  inline bool getInitialRefinmentTriggered() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._initialRefinmentTriggered;
                  }
                  
                  
                  
                  inline void setInitialRefinmentTriggered(const bool& initialRefinmentTriggered) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._initialRefinmentTriggered = initialRefinmentTriggered;
                  }
                  
                  
                  
                  inline int getUnknownsPerSubcell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._unknownsPerSubcell;
                  }
                  
                  
                  
                  inline void setUnknownsPerSubcell(const int& unknownsPerSubcell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._unknownsPerSubcell = unknownsPerSubcell;
                  }
                  
                  
                  
                  inline int getAuxiliarFieldsPerSubcell() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._auxiliarFieldsPerSubcell;
                  }
                  
                  
                  
                  inline void setAuxiliarFieldsPerSubcell(const int& auxiliarFieldsPerSubcell) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._auxiliarFieldsPerSubcell = auxiliarFieldsPerSubcell;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline tarch::la::Vector<DIMENSIONS,double> getInitialMinimalMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._initialMinimalMeshWidth;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline void setInitialMinimalMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& initialMinimalMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._initialMinimalMeshWidth = (initialMinimalMeshWidth);
                  }
                  
                  
                  
                  inline double getInitialMinimalMeshWidth(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     return _persistentRecords._initialMinimalMeshWidth[elementIndex];
                     
                  }
                  
                  
                  
                  inline void setInitialMinimalMeshWidth(int elementIndex, const double& initialMinimalMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     _persistentRecords._initialMinimalMeshWidth[elementIndex]= initialMinimalMeshWidth;
                     
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline tarch::la::Vector<DIMENSIONS,int> getDefaultSubdivisionFactor() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._defaultSubdivisionFactor;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline void setDefaultSubdivisionFactor(const tarch::la::Vector<DIMENSIONS,int>& defaultSubdivisionFactor) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._defaultSubdivisionFactor = (defaultSubdivisionFactor);
                  }
                  
                  
                  
                  inline int getDefaultSubdivisionFactor(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     return _persistentRecords._defaultSubdivisionFactor[elementIndex];
                     
                  }
                  
                  
                  
                  inline void setDefaultSubdivisionFactor(int elementIndex, const int& defaultSubdivisionFactor) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     _persistentRecords._defaultSubdivisionFactor[elementIndex]= defaultSubdivisionFactor;
                     
                  }
                  
                  
                  
                  inline int getDefaultGhostWidthLayer() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._defaultGhostWidthLayer;
                  }
                  
                  
                  
                  inline void setDefaultGhostWidthLayer(const int& defaultGhostWidthLayer) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._defaultGhostWidthLayer = defaultGhostWidthLayer;
                  }
                  
                  
                  
                  inline double getInitialTimestepSize() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._initialTimestepSize;
                  }
                  
                  
                  
                  inline void setInitialTimestepSize(const double& initialTimestepSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._initialTimestepSize = initialTimestepSize;
                  }
                  
                  
                  
                  inline bool getUseDimensionalSplittingOptimization() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._useDimensionalSplittingOptimization;
                  }
                  
                  
                  
                  inline void setUseDimensionalSplittingOptimization(const bool& useDimensionalSplittingOptimization) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._useDimensionalSplittingOptimization = useDimensionalSplittingOptimization;
                  }
                  
                  
                  
                  inline double getGlobalTimestepEndTime() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._globalTimestepEndTime;
                  }
                  
                  
                  
                  inline void setGlobalTimestepEndTime(const double& globalTimestepEndTime) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._globalTimestepEndTime = globalTimestepEndTime;
                  }
                  
                  
                  
                  inline bool getAllPatchesEvolvedToGlobalTimestep() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     short int mask = 1 << (0);
   short int tmp = static_cast<short int>(_persistentRecords._packedRecords0 & mask);
   return (tmp != 0);
                  }
                  
                  
                  
                  inline void setAllPatchesEvolvedToGlobalTimestep(const bool& allPatchesEvolvedToGlobalTimestep) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     short int mask = 1 << (0);
   _persistentRecords._packedRecords0 = static_cast<short int>( allPatchesEvolvedToGlobalTimestep ? (_persistentRecords._packedRecords0 | mask) : (_persistentRecords._packedRecords0 & ~mask));
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline tarch::la::Vector<DIMENSIONS,double> getDomainOffset() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._domainOffset;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline void setDomainOffset(const tarch::la::Vector<DIMENSIONS,double>& domainOffset) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._domainOffset = (domainOffset);
                  }
                  
                  
                  
                  inline double getDomainOffset(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     return _persistentRecords._domainOffset[elementIndex];
                     
                  }
                  
                  
                  
                  inline void setDomainOffset(int elementIndex, const double& domainOffset) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     _persistentRecords._domainOffset[elementIndex]= domainOffset;
                     
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline tarch::la::Vector<DIMENSIONS,double> getDomainSize() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._domainSize;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline void setDomainSize(const tarch::la::Vector<DIMENSIONS,double>& domainSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._domainSize = (domainSize);
                  }
                  
                  
                  
                  inline double getDomainSize(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     return _persistentRecords._domainSize[elementIndex];
                     
                  }
                  
                  
                  
                  inline void setDomainSize(int elementIndex, const double& domainSize) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     _persistentRecords._domainSize[elementIndex]= domainSize;
                     
                  }
                  
                  
                  
                  inline int getPlotNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._plotNumber;
                  }
                  
                  
                  
                  inline void setPlotNumber(const int& plotNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._plotNumber = plotNumber;
                  }
                  
                  
                  
                  inline int getSubPlotNumber() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._subPlotNumber;
                  }
                  
                  
                  
                  inline void setSubPlotNumber(const int& subPlotNumber) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._subPlotNumber = subPlotNumber;
                  }
                  
                  
                  
                  inline double getStartMaximumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._startMaximumGlobalTimeInterval;
                  }
                  
                  
                  
                  inline void setStartMaximumGlobalTimeInterval(const double& startMaximumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._startMaximumGlobalTimeInterval = startMaximumGlobalTimeInterval;
                  }
                  
                  
                  
                  inline double getEndMaximumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._endMaximumGlobalTimeInterval;
                  }
                  
                  
                  
                  inline void setEndMaximumGlobalTimeInterval(const double& endMaximumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._endMaximumGlobalTimeInterval = endMaximumGlobalTimeInterval;
                  }
                  
                  
                  
                  inline double getStartMinimumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._startMinimumGlobalTimeInterval;
                  }
                  
                  
                  
                  inline void setStartMinimumGlobalTimeInterval(const double& startMinimumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._startMinimumGlobalTimeInterval = startMinimumGlobalTimeInterval;
                  }
                  
                  
                  
                  inline double getEndMinimumGlobalTimeInterval() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._endMinimumGlobalTimeInterval;
                  }
                  
                  
                  
                  inline void setEndMinimumGlobalTimeInterval(const double& endMinimumGlobalTimeInterval) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._endMinimumGlobalTimeInterval = endMinimumGlobalTimeInterval;
                  }
                  
                  
                  
                  inline double getMinimalTimestep() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._minimalTimestep;
                  }
                  
                  
                  
                  inline void setMinimalTimestep(const double& minimalTimestep) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._minimalTimestep = minimalTimestep;
                  }
                  
                  
                  
                  inline double getTotalNumberOfCellUpdates() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._totalNumberOfCellUpdates;
                  }
                  
                  
                  
                  inline void setTotalNumberOfCellUpdates(const double& totalNumberOfCellUpdates) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._totalNumberOfCellUpdates = totalNumberOfCellUpdates;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline tarch::la::Vector<DIMENSIONS,double> getMinMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._minMeshWidth;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline void setMinMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& minMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._minMeshWidth = (minMeshWidth);
                  }
                  
                  
                  
                  inline double getMinMeshWidth(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     return _persistentRecords._minMeshWidth[elementIndex];
                     
                  }
                  
                  
                  
                  inline void setMinMeshWidth(int elementIndex, const double& minMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     _persistentRecords._minMeshWidth[elementIndex]= minMeshWidth;
                     
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline tarch::la::Vector<DIMENSIONS,double> getMaxMeshWidth() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._maxMeshWidth;
                  }
                  
                  
                  
                  /**
                   * Generated and optimized
                   * 
                   * If you realise a for loop using exclusively arrays (vectors) and compile 
                   * with -DUseManualAlignment you may add 
                   * \code
                   #pragma vector aligned
                   #pragma simd
                   \endcode to this for loop to enforce your compiler to use SSE/AVX.
                   * 
                   * The alignment is tied to the unpacked records, i.e. for packed class
                   * variants the machine's natural alignment is switched off to recude the  
                   * memory footprint. Do not use any SSE/AVX operations or 
                   * vectorisation on the result for the packed variants, as the data is misaligned. 
                   * If you rely on vectorisation, convert the underlying record 
                   * into the unpacked version first. 
                   * 
                   * @see convert()
                   */
                  inline void setMaxMeshWidth(const tarch::la::Vector<DIMENSIONS,double>& maxMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._maxMeshWidth = (maxMeshWidth);
                  }
                  
                  
                  
                  inline double getMaxMeshWidth(int elementIndex) const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     return _persistentRecords._maxMeshWidth[elementIndex];
                     
                  }
                  
                  
                  
                  inline void setMaxMeshWidth(int elementIndex, const double& maxMeshWidth) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     assertion(elementIndex>=0);
                     assertion(elementIndex<DIMENSIONS);
                     _persistentRecords._maxMeshWidth[elementIndex]= maxMeshWidth;
                     
                  }
                  
                  
                  
                  inline double getNumberOfInnerVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._numberOfInnerVertices;
                  }
                  
                  
                  
                  inline void setNumberOfInnerVertices(const double& numberOfInnerVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._numberOfInnerVertices = numberOfInnerVertices;
                  }
                  
                  
                  
                  inline double getNumberOfBoundaryVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._numberOfBoundaryVertices;
                  }
                  
                  
                  
                  inline void setNumberOfBoundaryVertices(const double& numberOfBoundaryVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._numberOfBoundaryVertices = numberOfBoundaryVertices;
                  }
                  
                  
                  
                  inline double getNumberOfOuterVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._numberOfOuterVertices;
                  }
                  
                  
                  
                  inline void setNumberOfOuterVertices(const double& numberOfOuterVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._numberOfOuterVertices = numberOfOuterVertices;
                  }
                  
                  
                  
                  inline double getNumberOfInnerCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._numberOfInnerCells;
                  }
                  
                  
                  
                  inline void setNumberOfInnerCells(const double& numberOfInnerCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._numberOfInnerCells = numberOfInnerCells;
                  }
                  
                  
                  
                  inline double getNumberOfOuterCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._numberOfOuterCells;
                  }
                  
                  
                  
                  inline void setNumberOfOuterCells(const double& numberOfOuterCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._numberOfOuterCells = numberOfOuterCells;
                  }
                  
                  
                  
                  inline double getNumberOfInnerLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._numberOfInnerLeafVertices;
                  }
                  
                  
                  
                  inline void setNumberOfInnerLeafVertices(const double& numberOfInnerLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._numberOfInnerLeafVertices = numberOfInnerLeafVertices;
                  }
                  
                  
                  
                  inline double getNumberOfBoundaryLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._numberOfBoundaryLeafVertices;
                  }
                  
                  
                  
                  inline void setNumberOfBoundaryLeafVertices(const double& numberOfBoundaryLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._numberOfBoundaryLeafVertices = numberOfBoundaryLeafVertices;
                  }
                  
                  
                  
                  inline double getNumberOfOuterLeafVertices() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._numberOfOuterLeafVertices;
                  }
                  
                  
                  
                  inline void setNumberOfOuterLeafVertices(const double& numberOfOuterLeafVertices) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._numberOfOuterLeafVertices = numberOfOuterLeafVertices;
                  }
                  
                  
                  
                  inline double getNumberOfInnerLeafCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._numberOfInnerLeafCells;
                  }
                  
                  
                  
                  inline void setNumberOfInnerLeafCells(const double& numberOfInnerLeafCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._numberOfInnerLeafCells = numberOfInnerLeafCells;
                  }
                  
                  
                  
                  inline double getNumberOfOuterLeafCells() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._numberOfOuterLeafCells;
                  }
                  
                  
                  
                  inline void setNumberOfOuterLeafCells(const double& numberOfOuterLeafCells) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._numberOfOuterLeafCells = numberOfOuterLeafCells;
                  }
                  
                  
                  
                  inline int getMaxLevel() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._maxLevel;
                  }
                  
                  
                  
                  inline void setMaxLevel(const int& maxLevel) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._maxLevel = maxLevel;
                  }
                  
                  
                  
                  inline bool getHasRefined() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     short int mask = 1 << (1);
   short int tmp = static_cast<short int>(_persistentRecords._packedRecords0 & mask);
   return (tmp != 0);
                  }
                  
                  
                  
                  inline void setHasRefined(const bool& hasRefined) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     short int mask = 1 << (1);
   _persistentRecords._packedRecords0 = static_cast<short int>( hasRefined ? (_persistentRecords._packedRecords0 | mask) : (_persistentRecords._packedRecords0 & ~mask));
                  }
                  
                  
                  
                  inline bool getHasTriggeredRefinementForNextIteration() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     short int mask = 1 << (2);
   short int tmp = static_cast<short int>(_persistentRecords._packedRecords0 & mask);
   return (tmp != 0);
                  }
                  
                  
                  
                  inline void setHasTriggeredRefinementForNextIteration(const bool& hasTriggeredRefinementForNextIteration) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     short int mask = 1 << (2);
   _persistentRecords._packedRecords0 = static_cast<short int>( hasTriggeredRefinementForNextIteration ? (_persistentRecords._packedRecords0 | mask) : (_persistentRecords._packedRecords0 & ~mask));
                  }
                  
                  
                  
                  inline bool getHasErased() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     short int mask = 1 << (3);
   short int tmp = static_cast<short int>(_persistentRecords._packedRecords0 & mask);
   return (tmp != 0);
                  }
                  
                  
                  
                  inline void setHasErased(const bool& hasErased) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     short int mask = 1 << (3);
   _persistentRecords._packedRecords0 = static_cast<short int>( hasErased ? (_persistentRecords._packedRecords0 | mask) : (_persistentRecords._packedRecords0 & ~mask));
                  }
                  
                  
                  
                  inline bool getHasTriggeredEraseForNextIteration() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     short int mask = 1 << (4);
   short int tmp = static_cast<short int>(_persistentRecords._packedRecords0 & mask);
   return (tmp != 0);
                  }
                  
                  
                  
                  inline void setHasTriggeredEraseForNextIteration(const bool& hasTriggeredEraseForNextIteration) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     short int mask = 1 << (4);
   _persistentRecords._packedRecords0 = static_cast<short int>( hasTriggeredEraseForNextIteration ? (_persistentRecords._packedRecords0 | mask) : (_persistentRecords._packedRecords0 & ~mask));
                  }
                  
                  
                  
                  inline bool getHasChangedVertexOrCellState() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     short int mask = 1 << (5);
   short int tmp = static_cast<short int>(_persistentRecords._packedRecords0 & mask);
   return (tmp != 0);
                  }
                  
                  
                  
                  inline void setHasChangedVertexOrCellState(const bool& hasChangedVertexOrCellState) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     short int mask = 1 << (5);
   _persistentRecords._packedRecords0 = static_cast<short int>( hasChangedVertexOrCellState ? (_persistentRecords._packedRecords0 | mask) : (_persistentRecords._packedRecords0 & ~mask));
                  }
                  
                  
                  
                  inline bool getIsTraversalInverted() const 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     return _persistentRecords._isTraversalInverted;
                  }
                  
                  
                  
                  inline void setIsTraversalInverted(const bool& isTraversalInverted) 
 #ifdef UseManualInlining
 __attribute__((always_inline))
 #endif 
 {
                     _persistentRecords._isTraversalInverted = isTraversalInverted;
                  }
                  
                  
                  /**
                   * Generated
                   */
                  std::string toString() const;
                  
                  /**
                   * Generated
                   */
                  void toString(std::ostream& out) const;
                  
                  
                  PersistentRecords getPersistentRecords() const;
                  /**
                   * Generated
                   */
                  State convert() const;
                  
                  
               #ifdef Parallel
                  protected:
                     static tarch::logging::Log _log;
                     
                     int _senderDestinationRank;
                     
                  public:
                     
                     /**
                      * Global that represents the mpi datatype.
                      * There are two variants: Datatype identifies only those attributes marked with
                      * parallelise. FullDatatype instead identifies the whole record with all fields.
                      */
                     static MPI_Datatype Datatype;
                     static MPI_Datatype FullDatatype;
                     
                     /**
                      * Initializes the data type for the mpi operations. Has to be called
                      * before the very first send or receive operation is called.
                      */
                     static void initDatatype();
                     
                     static void shutdownDatatype();
                     
                     void send(int destination, int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
                     
                     void receive(int source, int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
                     
                     static bool isMessageInQueue(int tag, bool exchangeOnlyAttributesMarkedWithParallelise);
                     
                     int getSenderRank() const;
                     
               #endif
                  
               };
               
               #ifdef PackedRecords
               #pragma pack (pop)
               #endif
               
               
               
            
         #endif
         
         #endif
         
